# -*- coding: utf-8 -*-
"""
	Pygments to CodeMirror mode Converter
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	:author: ComFreek <comfreek@outlook.com>
	:copyright: Copyright 2020 ComFreek
	:license: ISC, see LICENSE for details.
"""

import re

from pygments.token import Comment, Generic, Keyword, Literal, \
	Name, Number, Punctuation, String, Token, Whitespace

from pygments_converter import PygmentsConverter

class PygmentsToCodeMirrorConverter(PygmentsConverter):
	target_start_state_name = 'start'

	def transform_regex(self, regex, python_flags):
		target = "/" + regex + "/u" # handle Unicode always correctly

		if re.IGNORECASE in python_flags:
			target += "i"
		if re.MULTILINE in python_flags:
			target += "m"
		if re.DOTALL in python_flags:
			target += "s"
	
		return target

	def transform_single_token_type(self, token_type):
		# Pygments token form a hierarchy
		# e.g. Token
		#      /     \
		# Keyword     Comment
		#  /               \
		# Declaration       Multiline
		#
		# the 'in' operator is in particular overloaded to check whether
		# one token is derived (a [possibly indirect] child) from another

		if token_type in Token.Text.Whitespace:
			return '"whitespace"'
		elif token_type in Token.Text:
			return '"string-2"'
		if token_type in Token.Keyword:
			return '"keyword"'
		elif token_type in Token.Comment:
			return '"comment"'
		elif token_type in Token.String:
			return '"string"'
		elif token_type in Token.Punctuation:
			return '"punctuation"'
		elif token_type in Token.Name.Class:
			return '"variable"'
		elif token_type in Token.Name.Constant:
			return '"variable-2"'
		elif token_type in Token.Name.Variable:
			return '"variable-3"'
		elif token_type in Token.Literal.URI:
			return '"link"'
		elif token_type in Token.Literal:
			return '"number"' # crude approximation
			
		else:
			token_type = str(token_type).replace('Token.','')
			return f"'{token_type}'"

	def transform_token_types(self, token_types):
		token_types = list(map(self.transform_single_token_type, token_types))

		if len(token_types) == 1:
			return token_types[0]
		else:
			return f"[{', '.join(token_types)}]"

	def transform_transition(self, next_state_type, next_state_info, indentation):
		if next_state_type == 'push':
			transition = ', '.join(map(lambda s: f'"{s}"', next_state_info))
			return f", transition: {transition}"
		elif next_state_type == 'pop':
			# next_state_info is number of states to be popped
			if next_state_info == 1:
				return ', transition: "#pop"'
			else:
				return ', transition: "#pop:' + str(next_state_info) + '"'
		else:
			return '' # Do nothing

	def transform_rule(self, regex, token_types, next_state_type, next_state_info, indentation = "", regex_python_flags = []):
		return "{}{{regex: {}, token: {}{}}},\n".format(
			indentation,
			self.transform_regex(regex, regex_python_flags),
			self.transform_token_types(token_types),
			self.transform_transition(next_state_type, next_state_info, indentation + '\t'),
		)

	def transform_state_header(self, state):
		return f'\t\t"{state}": [\n'

	def transform_state_footer(self, state):
		return "\t\t],\n"

	def transform_lexer_header(self, python_lexer_class):
		print(f"INFO: ignoring {python_lexer_class}.{{aliases, filenames}} for conversion since CodeMirror doesn't have such concepts")

		mode_name = python_lexer_class.codemirror_name

		return """// remove this (?): CodeMirror, copyright (c) by Marijn Haverbeke and others
// remove this (?): Distributed under an MIT license: https://codemirror.net/LICENSE

// DO NOT EDIT - AUTOGENERATED
//
// This mode has been autogenerated from the Pygments lexer [1] by the script [2].
//
// [1]: {python_lexer_source}
// [2]: https://github.com/ComFreek/mmtpygments/blob/master/mmtpygments/pygments_to_codemirror.py

(function(mod) {{
	if (typeof exports == "object" && typeof module == "object") // CommonJS
		mod(require("../../lib/codemirror"));
	else if (typeof define == "function" && define.amd) // AMD
		define(["../../lib/codemirror"], mod);
	else // Plain browser env
		mod(CodeMirror);
}})(function(CodeMirror) {{
	"use strict";

	{mime_type_declarations}

	CodeMirror.defineAdvancedMode("{mode_name}", {{
""".format(
		python_lexer_source = python_lexer_class.rouge_original_source,
		mime_type_declarations = '\n'.join(map(
			lambda mime: self.transform_mimetype(mode_name, mime),
			python_lexer_class.mimetypes
		)),
		mode_name = mode_name
	)

	def transform_lexer_footer(self, regex_lexer):
		return "\t});\n});"

	def transform_mimetype(self, mode_name, mimetype):
		return f'CodeMirror.defineMIME("{mimetype}", "{mode_name}");'
