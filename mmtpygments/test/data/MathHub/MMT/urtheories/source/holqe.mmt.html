<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<!--
generated by Pygments <https://pygments.org/>
Copyright 2006-2020 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
-->
<html>
<head>
  <title></title>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <style type="text/css">
/*
generated by Pygments <https://pygments.org/>
Copyright 2006-2020 by the Pygments team.
Licensed under the BSD license, see LICENSE for details.
*/
pre { line-height: 125%; margin: 0; }
td.linenos pre { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
span.linenos { color: #000000; background-color: #f0f0f0; padding-left: 5px; padding-right: 5px; }
td.linenos pre.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
body .hll { background-color: #ffffcc }
body { background: #f8f8f8; }
body .c { color: #408080; font-style: italic } /* Comment */
body .err { border: 1px solid #FF0000 } /* Error */
body .k { color: #008000; font-weight: bold } /* Keyword */
body .-MMT_DD { color: #D3D3D3 } /* MMT_DD */
body .-MMT_MD { color: #D3D3D3 } /* MMT_MD */
body .-MMT_OD { color: #D3D3D3 } /* MMT_OD */
body .o { color: #666666 } /* Operator */
body .ch { color: #408080; font-style: italic } /* Comment.Hashbang */
body .cm { color: #408080; font-style: italic } /* Comment.Multiline */
body .cp { color: #BC7A00 } /* Comment.Preproc */
body .cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
body .c1 { color: #408080; font-style: italic } /* Comment.Single */
body .cs { color: #408080; font-style: italic } /* Comment.Special */
body .gd { color: #A00000 } /* Generic.Deleted */
body .ge { font-style: italic } /* Generic.Emph */
body .gr { color: #FF0000 } /* Generic.Error */
body .gh { color: #000080; font-weight: bold } /* Generic.Heading */
body .gi { color: #00A000 } /* Generic.Inserted */
body .go { color: #888888 } /* Generic.Output */
body .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
body .gs { font-weight: bold } /* Generic.Strong */
body .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
body .gt { color: #0044DD } /* Generic.Traceback */
body .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
body .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
body .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
body .kp { color: #008000 } /* Keyword.Pseudo */
body .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
body .kt { color: #B00040 } /* Keyword.Type */
body .m { color: #666666 } /* Literal.Number */
body .s { color: #BA2121 } /* Literal.String */
body .na { color: #7D9029 } /* Name.Attribute */
body .nb { color: #008000 } /* Name.Builtin */
body .nc { color: #0000FF; font-weight: bold } /* Name.Class */
body .no { color: #880000 } /* Name.Constant */
body .nd { color: #AA22FF } /* Name.Decorator */
body .ni { color: #999999; font-weight: bold } /* Name.Entity */
body .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
body .nf { color: #0000FF } /* Name.Function */
body .nl { color: #A0A000 } /* Name.Label */
body .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
body .nt { color: #008000; font-weight: bold } /* Name.Tag */
body .nv { color: #19177C } /* Name.Variable */
body .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
body .w { color: #bbbbbb } /* Text.Whitespace */
body .mb { color: #666666 } /* Literal.Number.Bin */
body .mf { color: #666666 } /* Literal.Number.Float */
body .mh { color: #666666 } /* Literal.Number.Hex */
body .mi { color: #666666 } /* Literal.Number.Integer */
body .mo { color: #666666 } /* Literal.Number.Oct */
body .sa { color: #BA2121 } /* Literal.String.Affix */
body .sb { color: #BA2121 } /* Literal.String.Backtick */
body .sc { color: #BA2121 } /* Literal.String.Char */
body .dl { color: #BA2121 } /* Literal.String.Delimiter */
body .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
body .s2 { color: #BA2121 } /* Literal.String.Double */
body .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
body .sh { color: #BA2121 } /* Literal.String.Heredoc */
body .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
body .sx { color: #008000 } /* Literal.String.Other */
body .sr { color: #BB6688 } /* Literal.String.Regex */
body .s1 { color: #BA2121 } /* Literal.String.Single */
body .ss { color: #19177C } /* Literal.String.Symbol */
body .bp { color: #008000 } /* Name.Builtin.Pseudo */
body .fm { color: #0000FF } /* Name.Function.Magic */
body .vc { color: #19177C } /* Name.Variable.Class */
body .vg { color: #19177C } /* Name.Variable.Global */
body .vi { color: #19177C } /* Name.Variable.Instance */
body .vm { color: #19177C } /* Name.Variable.Magic */
body .il { color: #666666 } /* Literal.Number.Integer.Long */

  </style>
</head>
<body>
<h2></h2>

<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="l l-URI">http://cds.omdoc.org/urtheories</span><span class=" -MMT_MD">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="l l-URI">scala://quotation.mmt.kwarc.info</span><span class=" -MMT_MD">❚</span><span class="w"></span>

<span class="cm">/T   higher-order logic with quotation and evaluation, mostly following Bill Farmer&#39;s work ❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nc">HOLQE</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="l l-URI">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="sd"># Higher-order logic</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">   </span><span class="sd">## Types</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T the LF-type representing HOL types ❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">tp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">type</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T function types ❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">fun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tp ⟶ tp ⟶ tp</span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="ss">⇒</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Normally we represent object language variables using LF variables, in which case the following is redundant.</span>
<span class="cm">      But Farmer&#39;s language follows the traditional style of assuming an infinite supply of variables at every type.</span>
<span class="cm">      It is critical to capture this in the representation because he allows quoting terms with free variables.❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the type of variables at a given HOL type❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">Var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tp ⟶ type</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the constructor for concrete variables %x:a at a given HOL type where x is any identifier that is parsed as a closed term</span>
<span class="cm">      Most of the time, we do not need this because we can use LF-variables v:Var a as meta-variables that range over HOL variables at type a.❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">var</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">%</span><span class="w"> </span><span class="si">L1T</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">200</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the typing rule (%x:a):Var a for concrete variables cannot be expressed in LF, so we implement an MMT rule❙</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="l l-URI">rules?ConcreteVariable</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd">## Terms</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the LF-type representing HOL terms of a given HOL type ❙</span><span class="w">  </span>
<span class="w">   </span><span class="vc">tm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tp ⟶ type</span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">tm</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T all variables are terms of their respective type ❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">tvar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} Var a ⟶ tm a</span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="ss">tvar</span><span class="w"> </span><span class="si">2</span><span class=" -MMT_OD">❘</span><span class="p">##</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T λ-abstraction (contrary to typical LF-encodings, we bind explicit variables that have to be injected into terms using tvar ❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a, b} (Var a ⟶ tm b) ⟶ tm a ⇒ b</span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">λ</span><span class="w"> </span><span class="si">3</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T application ❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a, b} tm a ⇒ b ⟶ tm a ⟶ tm b</span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="ss">@</span><span class="w"> </span><span class="si">4</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T undefined terms (not needed here, but probably needed later on when evaluating quotations of ill-typed terms❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">undefined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} tm a</span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="ss">⊥</span><span class="w"> </span><span class="si">1</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T booleans, connectives, and proofs❙</span><span class="w"> </span>
<span class="w">   </span><span class="vc">bool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tp</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">equal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} tm a ⟶ tm a ⟶ tm bool </span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="ss">=</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="vc">ded</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm bool ⟶ type</span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">⊦</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd"># Quotation</span><span class=" -MMT_DD">❙</span><span class="w"> </span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T We add HOL types that reify HOL concepts❙</span><span class="w"> </span>

<span class="w">   </span><span class="sd">## Quoting Terms</span><span class=" -MMT_DD">❙</span><span class="w"> </span>

<span class="w">   </span><span class="cm">/T We add a type holding quotations of HOL terms. All terms may be quoted, including ill-typed ones.</span>
<span class="cm">      Effectively, this amounts to having a type that represents the untype λ-calculus inside a typed λ-calculus.❙</span><span class="w"> </span>

<span class="w">   </span><span class="sd">### Syntax</span><span class=" -MMT_DD">❙</span><span class="w">    </span>
<span class="w">      </span>
<span class="w">   </span><span class="cm">/T the type of quoted terms❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">qtp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tp </span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">ε</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted variables❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">qvar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} Var a ⟶ tm ε</span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="ss">qvar</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class=" -MMT_OD">❘</span><span class="p">##</span><span class="w"> </span><span class="ss">qvar</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted λ-abstractions❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">qlam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} Var a ⟶ tm ε ⟶ tm ε </span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">qlam</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="ss">.</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">150</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted applications❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">qapp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm ε ⟶ tm ε ⟶ tm ε </span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">qapp</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted quotations❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">qquote</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm ε ⟶ tm ε</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Finally, we add a meta-level operation that turns a term into the corresponding quotation.</span>
<span class="cm">      We may think of it as having type ${a}tm a ⟶ tm ε$ except. However, quotation may not be subject to congruence and therefore cannot have an LF type.❙</span><span class="w">   </span>
<span class="w">   </span><span class="vc">quote</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">⌜</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="ss">⌝</span><span class="w">  </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the rule that eliminates occurrences of quote by constructing the corresponding term of type $tm ε$</span>
<span class="cm">      HOL variables in the argument are quoted using $qvar$, LF variables remain, which gives rise to quasi-quotation.❙</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="l l-URI">rules?QuoteTerm</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="sd">### Semantics</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T the predicate expressing that a term is the quotation of a term of a given types.❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">oftype</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm ε ⟶ tp ⟶ tm bool</span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="ss">$</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted variables❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">oftype_var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a,v: Var a} ⊦ qvar v $ a</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted λ-abstractions❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">oftype_lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a,b,v:Var a,E} ⊦ E $ b ⟶ ⊦ qlam v.E $ a ⇒ b</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted applications❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">oftype_app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a,b,F,E} ⊦ F $ a ⇒ b ⟶ ⊦ E $ a ⟶ ⊦ qapp F E $ a ⇒ b</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted quotations❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">oftype_quote</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{E,a} ⊦ E $ a ⟶ ⊦ qquote E $ ε</span><span class=" -MMT_DD">❙</span><span class="w">   </span>

<span class="w">   </span><span class="sd">## Quoting Substitutions</span><span class=" -MMT_DD">❙</span><span class="w"> </span>

<span class="w">   </span><span class="cm">/T Expanding on Farmer&#39;s work, we also add a type holding HOL substitutions.</span>
<span class="cm">      Effectively, this amounts to a language with explicit substitutions.</span>
<span class="cm">      Because all variables are always in scope, every substitution maps all variables to terms.❙</span><span class="w"> </span>

<span class="w">   </span><span class="sd">### Syntax</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the type of substitutions❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">stp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tp</span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">sub</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the identity substitutions❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">idsub</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm sub</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the substitution that modifies a given substitution in one place❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">update</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} tm sub ⟶ Var a ⟶ tm a ⟶ tm sub </span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="ss">+</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="ss">↦</span><span class="w"> </span><span class="si">4</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">50</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T abbreviation for the substitution that maps one variable❙</span><span class="w">   </span>
<span class="w">   </span><span class="vc">singlesub</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} Var a ⟶ tm a ⟶ tm sub </span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="ss">↦</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">51</span><span class=" -MMT_OD">❘</span><span class="w"></span>
<span class="w">            </span><span class="p">=</span><span class="w"> </span><span class=" -MMT_ObjectExpression">[a,v,t] idsub + v ↦ t</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Finally, we add a meta-level operation that turns a substitution into the corresponding quotation.❙</span><span class="w">   </span>
<span class="w">   </span><span class="vc">subs</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">`</span><span class="w"> </span><span class="si">L1T</span><span class="ss">,</span><span class="si">…</span><span class="w"> </span><span class="ss">´</span><span class="w">  </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the rule that eliminates occurrences of subs by constructing the corresponding term of type $tm sub$❙</span><span class="w"> </span>
<span class="w">   </span><span class="cm">// rule rules?QuoteSubs❙</span><span class="w"></span>

<span class="w">   </span><span class="sd">### Semantics</span><span class=" -MMT_DD">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T an auxiliary predicate to reason about inequality of variables❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">diff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a,b} Var a ⟶ Var b ⟶ tm bool </span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="ss">≠</span><span class="w"> </span><span class="si">4</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class=" -MMT_DD">❙</span><span class="w"> </span><span class="cm">// notation parsing errors not reported correctly? ❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the function that retrieves the map of a variable by a substitution❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">lookup</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} tm sub ⟶ Var a ⟶ tm a </span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="ss">&#39;</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">15</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for the identity substitution❙</span><span class="w">   </span>
<span class="w">   </span><span class="vc">subst_id</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a,v: Var a} ⊦ v&#39;idsub = (tvar v)</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for an update to the needed variables❙</span><span class="w">   </span>
<span class="w">   </span><span class="vc">subst_update_same</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{s,a, v: Var a, E} ⊦ v&#39;(s+v↦E) = E</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for an update to some other variable❙</span><span class="w">   </span>
<span class="w">   </span><span class="vc">subst_update_diff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{s,a,b, v: Var a, w: Var b, E} ⊦ v ≠ w ⟶ ⊦ v&#39;(s+w↦E) = v&#39;s</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd"># Evaluation</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T Evaluation internalizes the model-theoretical semantics: evaluation takes a term and a substitution (which provides the assignment to the free variables) and returns its interpretation in the model.</span>
<span class="cm">   </span>
<span class="cm">   Evaluation is only defined for quotations of well-typed terms. Because the type of a quotation is not stored in the quotation,</span>
<span class="cm">   * evaluation takes a HOL-type as an additional argument,</span>
<span class="cm">   * evaluation rules take typing assumptions.❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the evaluation operator❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">eval</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a} tm ε ⟶ tm sub ⟶ tm a </span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">#</span><span class="w"> </span><span class="ss">⟦</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="ss">$</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="ss">⟧</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class=" -MMT_OD">❘</span><span class="w"> </span><span class="p">##</span><span class="w"> </span><span class="ss">⟦</span><span class="w"> </span><span class="si">2</span><span class="w"> </span><span class="ss">$</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="ss">⟧</span><span class="w"> </span><span class="ss">^</span><span class="w"> </span><span class="si">3</span><span class="w"> </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for variables: apply the assignment❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">eval_var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a, v: Var a, s} ⊦ (⟦qvar v $ a⟧s) = v&#39;s</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for λ-abstractions qlam v.E: build the function that maps x to the evaluation of E under the assignment of v to x❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">eval_fun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a, b, v: Var a, E, s} ⊦ E $ b ⟶ ⊦ (⟦qlam v.E $ a ⇒ b⟧s) = λ[x](⟦E $ b⟧ s + v ↦ tvar x)</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for applications: straightforward❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">eval_app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{a,b, F, X, s} ⊦ F $ a ⇒ b  ⟶  ⊦ X $ a  ⟶  ⊦ (⟦qapp F X $ b⟧s) = (⟦F $ a ⇒ b⟧s) @ ⟦X $ a⟧s</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for quotations: evaluation cancels quotation❙</span><span class="w"></span>
<span class="w">   </span><span class="vc">eval_quote</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{X, s} ⊦ X $ ε  ⟶  ⊦ (⟦qquote X $ ε⟧s) = X</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class=" -MMT_MD">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="cm">/T Now we formalize two challenge problems posed by Farmer❚</span><span class="w"></span>
<span class="w"> </span>
<span class="kd">theory</span><span class="w"> </span><span class="nc">ExcludedMiddle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="l l-URI">?HOLQE</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="vc">not</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm bool ⟶ tm bool</span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="ss">¬</span><span class="w"> </span><span class="si">1</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">  </span><span class="vc">or</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm bool ⟶ tm bool ⟶ tm bool</span><span class=" -MMT_OD">❘</span><span class="p">#</span><span class="w"> </span><span class="si">1</span><span class="w"> </span><span class="ss">∨</span><span class="w"> </span><span class="si">2</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">  </span><span class="vc">em</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{f,s} ⊦ f $ bool ⟶ ⊦ (⟦f$bool⟧s) ∨ ¬ ⟦f$bool⟧s </span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class=" -MMT_MD">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nc">PolyDiff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="l l-URI">?HOLQE</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T real numbers and derivatives❙</span><span class="w"></span>
<span class="w">  </span><span class="vc">R</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tp</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">  </span><span class="vc">derivative</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm R ⇒ R ⟶ tm R ⇒ R</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T a transformer that computes the derivative of a polynomial and its meaning formula❙</span><span class="w"></span>
<span class="w">  </span><span class="vc">ispolyin</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm ε ⟶ Var R ⟶ tm bool</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">  </span><span class="vc">polyderiv</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">tm ε ⟶ Var R ⟶ tm ε</span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class="w">  </span><span class="vc">meaning</span><span class="p">:</span><span class="w"> </span><span class=" -MMT_ObjectExpression">{v, p} ⊦ ispolyin p v ⟶ ⊦ derivative (λ[x] ⟦p $ R⟧v ↦ tvar x) = (λ[x] ⟦polyderiv p v $ R⟧v ↦ tvar x) </span><span class=" -MMT_DD">❙</span><span class="w"></span>
<span class=" -MMT_MD">❚</span><span class="w"></span>
</pre></div>
</body>
</html>
