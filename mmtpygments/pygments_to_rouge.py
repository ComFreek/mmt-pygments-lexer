# -*- coding: utf-8 -*-
"""
	Pygments to Rouge Lexer Converter
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	:author: ComFreek <comfreek@outlook.com>
	:copyright: Copyright 2020 ComFreek
	:license: ISC, see LICENSE for details.
"""

import re

from pygments_converter import PygmentsConverter

class PygmentsToRougeConverter(PygmentsConverter):
	def transform_regex(self, regex, python_flags):
		ruby = "%r/" + regex + "/"
		if re.IGNORECASE in python_flags:
			ruby += "i"

		# Ruby cannot distinguish between these flags
		if re.MULTILINE in python_flags or re.DOTALL in python_flags:
			ruby += "m"
	
		return ruby

	def transform_single_token_type(self, token_type):
		token_type = str(token_type).replace('Token.','').replace('.','::')
	
		# Post-hoc fixes
		# TODO: provide a customizable option to deal with such custom token types
		if token_type == 'Literal::URI' or token_type.startswith('MMT'):
			token_type = 'Text'
	
		return token_type

	def transform_token_types(self, token_types):
		token_types = list(map(self.transform_single_token_type, token_types))

		return ('groups ' if len(token_types) > 1 else 'token ' )+ ','.join(token_types)

	def transform_transition(self, next_state_type, next_state_info, indentation):
		if next_state_type == 'push':
			return '\n'.join(map(
				lambda new_state: '{}push :{}'.format(indentation, new_state),
				next_state_info
			)) + '\n'
		elif next_state_type == 'pop':
			# next_state_info is number of states to be popped
			return '{}pop!({})\n'.format(indentation, next_state_info)
		else:
			return '' # Do nothing

	def transform_rule(self, regex, token_types, next_state_type, next_state_info, indentation = "", regex_python_flags = []):
		return "{}rule {} do\n{}\n{}{}end\n".format(
			indentation,
			self.transform_regex(regex, regex_python_flags),
			indentation + '\t' + self.transform_token_types(token_types),
			self.transform_transition(next_state_type, next_state_info, indentation + '\t'),
			indentation
		)

	def transform_state_header(self, state):
		return "\t\t\tstate :" + state + " do\n"

	def transform_state_footer(self, state):
		return "\t\t\tend\n"

	def transform(self, regex_lexer):
		'''
		Transform a Pygments regex lexer class
		'''

		target = ""
		
		target += self.transform_lexer_header(regex_lexer)
		
		for state, rules in regex_lexer.tokens.items():
			target += self.transform_state_header(state)

			for rule in rules:
				regex = rule[0]
				token_type = rule[1]
				if not type(token_type) is tuple:
					token_type = [token_type]
			
				next_state_type = None
				next_state_info = None

				if len(rule) == 3 and isinstance(rule[2], str):
					if rule[2] == '#pop':
						next_state_type = 'pop'
						next_state_info = 1
					elif rule[2].startswith("#pop:"): # pop the number of states given after colon
						number_of_states = int(rule[2][len("#pop:"):]) 

						next_state_type = 'pop'
						next_state_info = number_of_states
					else:
						next_state_type = 'push'
						next_state_info = [rule[2]] # push a single state
				elif len(rule) == 3 and isinstance(rule[2], tuple):
					# rule[2] contains a list of states to be pushed
					next_state_type = 'push'
					next_state_info = rule[2]
			
				target += self.transform_rule(regex, token_type, next_state_type, next_state_info, indentation="\t\t\t\t", regex_python_flags=regex_lexer.flags)

			target += self.transform_state_footer(state)
	
		target += self.transform_lexer_footer(regex_lexer)

		return target
	
	def transform_lexer_footer(self, regex_lexer):
		return "\t\tend\n\tend\nend\n"

	def transform_lexer_header(self, python_lexer_class):
		return """# -*- coding: utf-8 -*- #
# frozen_string_literal: true

# DO NOT EDIT - AUTOGENERATED
#
# This Rouge lexer file has been autogenerated from the Pygments lexer [1] by the script [2].
#
# [1]: {python_lexer_source}
# [2]: https://github.com/ComFreek/mmtpygments/blob/master/mmtpygments/pygments_to_rouge.py

module Rouge
	module Lexers
		class {class_name} < RegexLexer
			title '{title}'
			desc <<-DESC
{description}
DESC
			tag '{tag}'
			mimetypes {mimetypes}
			filenames {filenames}
""".format(
		python_lexer_source = python_lexer_class.rouge_original_source,
		class_name = python_lexer_class.rouge_name,
		title = python_lexer_class.rouge_title,
		description = python_lexer_class.rouge_description,
		tag = python_lexer_class.rouge_tag,
		mimetypes = ','.join(map(lambda s: "'{}'".format(s), python_lexer_class.mimetypes)),
		filenames = ','.join(map(lambda s: "'{}'".format(s), python_lexer_class.filenames))
	)
