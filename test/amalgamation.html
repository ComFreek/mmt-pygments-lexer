
<!doctype html>
<html>
	<head>
		<meta charset="utf-8">

		<!-- Don't cache! -->
		<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
		<meta http-equiv="Pragma" content="no-cache" />
		<meta http-equiv="Expires" content="0">

		<title>Amalgamation of Render Results - mmt-pygments-lexer</title>
	</head>
	<body>
		<h1>Amalgamation of Render Results</h1>
<style>.hll { background-color: #ffffcc }
.c { color: #408080; font-style: italic } /* Comment */
.err { border: 1px solid #FF0000 } /* Error */
.k { color: #008000; font-weight: bold } /* Keyword */
.o { color: #666666 } /* Operator */
.ch { color: #408080; font-style: italic } /* Comment.Hashbang */
.cm { color: #408080; font-style: italic } /* Comment.Multiline */
.cp { color: #BC7A00 } /* Comment.Preproc */
.cpf { color: #408080; font-style: italic } /* Comment.PreprocFile */
.c1 { color: #408080; font-style: italic } /* Comment.Single */
.cs { color: #408080; font-style: italic } /* Comment.Special */
.gd { color: #A00000 } /* Generic.Deleted */
.ge { font-style: italic } /* Generic.Emph */
.gr { color: #FF0000 } /* Generic.Error */
.gh { color: #000080; font-weight: bold } /* Generic.Heading */
.gi { color: #00A000 } /* Generic.Inserted */
.go { color: #888888 } /* Generic.Output */
.gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.gs { font-weight: bold } /* Generic.Strong */
.gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.gt { color: #0044DD } /* Generic.Traceback */
.kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.kp { color: #008000 } /* Keyword.Pseudo */
.kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.kt { color: #B00040 } /* Keyword.Type */
.m { color: #666666 } /* Literal.Number */
.s { color: #BA2121 } /* Literal.String */
.na { color: #7D9029 } /* Name.Attribute */
.nb { color: #008000 } /* Name.Builtin */
.nc { color: #0000FF; font-weight: bold } /* Name.Class */
.no { color: #880000 } /* Name.Constant */
.nd { color: #AA22FF } /* Name.Decorator */
.ni { color: #999999; font-weight: bold } /* Name.Entity */
.ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.nf { color: #0000FF } /* Name.Function */
.nl { color: #A0A000 } /* Name.Label */
.nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.nt { color: #008000; font-weight: bold } /* Name.Tag */
.nv { color: #19177C } /* Name.Variable */
.ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.w { color: #bbbbbb } /* Text.Whitespace */
.mb { color: #666666 } /* Literal.Number.Bin */
.mf { color: #666666 } /* Literal.Number.Float */
.mh { color: #666666 } /* Literal.Number.Hex */
.mi { color: #666666 } /* Literal.Number.Integer */
.mo { color: #666666 } /* Literal.Number.Oct */
.sa { color: #BA2121 } /* Literal.String.Affix */
.sb { color: #BA2121 } /* Literal.String.Backtick */
.sc { color: #BA2121 } /* Literal.String.Char */
.dl { color: #BA2121 } /* Literal.String.Delimiter */
.sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.s2 { color: #BA2121 } /* Literal.String.Double */
.se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.sh { color: #BA2121 } /* Literal.String.Heredoc */
.si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.sx { color: #008000 } /* Literal.String.Other */
.sr { color: #BB6688 } /* Literal.String.Regex */
.s1 { color: #BA2121 } /* Literal.String.Single */
.ss { color: #19177C } /* Literal.String.Symbol */
.bp { color: #008000 } /* Name.Builtin.Pseudo */
.fm { color: #0000FF } /* Name.Function.Magic */
.vc { color: #19177C } /* Name.Variable.Class */
.vg { color: #19177C } /* Name.Variable.Global */
.vi { color: #19177C } /* Name.Variable.Instance */
.vm { color: #19177C } /* Name.Variable.Magic */
.il { color: #666666 } /* Literal.Number.Integer.Long */</style><div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Coproducts</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://Coproducts.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">Coprod</span><span class="w"> </span><span class="p">#</span><span class="s"> 1⨁…  </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">inl</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ↪l 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">inr</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 r↩ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">coprodmatch</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 match V1 . 3|… to 4 %I5 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">coprodmatch2</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 match 5 , V1 . 3|… to 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9001</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">FuncaddSymbol</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">Addfunc</span><span class="w"> </span><span class="p">#</span><span class="s"> 1⊕… </span><span class="k">prec</span><span class="w"> </span><span class="mi">0</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">SimpleRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?CoprodTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?inlTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?inrTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MatchTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MatchComp </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// rule rules?MatchEquality ❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?CoprodSubType </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedCoproduct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?TermsTypesKinds</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?SimpleRules </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>


<span class="kd">theory</span><span class="w"> </span><span class="nv">FuncaddRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?AddFuncComp </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFCoprod</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?FuncaddSymbol </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?FuncaddRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedCoproduct </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Datatypes</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://datatypes.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ListSymbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">ListType</span><span class="w"> </span><span class="p">#</span><span class="s"> List 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-500</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">nil</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">ls</span><span class="w"> </span><span class="p">#</span><span class="s"> ls 1,… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-500</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">append</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ++ 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">map</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 map 2 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ListRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ListTypeRule </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ListVariance </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ListCheckRule </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?AppendType </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MapType </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MapComp </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFLists</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?ListSymbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?ListRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LetSymbol</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="no">Let</span><span class="w"> </span><span class="p">#</span><span class="s"> Let V1 = 2 in 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LetRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LetRule </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFLet</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?LetSymbol </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?LetRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SubSymbol</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="no">substitute</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 sub 2 / 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SubRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SubRule </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFSub</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SubSymbol </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SubRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Equality</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://Equality.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">eqtype</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ≐ 2 on 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-500</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">refl</span><span class="w"> </span><span class="p">#</span><span class="s"> refl 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">ind</span><span class="w"> </span><span class="p">#</span><span class="s"> ind 4 . V1 , V2 , V3 ⟹ 5 to 6</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Rules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EqFormation </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ReflIntro </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EqIndElim </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EqIndComp </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedEquality</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?TermsTypesKinds </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Rules </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFEquality</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedEquality </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Finite</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://FiniteTypes.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LambdaPi </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">emptyType</span><span class="w"> </span><span class="p">#</span><span class="s"> ∅ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">emptyFun</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ∅f 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-900</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">UNIT</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">unite</span><span class="w"> </span><span class="p">#</span><span class="s"> ★ </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?Typed </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?Kinded </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EmptyTypeFormation </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnitTypeFormation </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnitIntro </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EmptyElim </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnitIrrelevance </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SubTypedRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EmptySub </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EmptyFunComputation </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">EnumSymbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">ENUM</span><span class="w"> </span><span class="p">#</span><span class="s"> ENUM 1 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">CASE</span><span class="w"> </span><span class="p">#</span><span class="s"> CASE 1 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">EnumRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?NatLiteralsOnly </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?SubTypedRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EnumFormation </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?CaseIntroduction </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?CaseTyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?CaseSubtyping </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">EnumCoprodRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?EnumRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Coproducts?TypedCoproduct </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EnumComputation </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?CaseComputation </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">DefinedUnitRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnitComputation </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnitElemComputation </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFFiniteBase</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?EnumSymbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?DefinedUnitRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?EnumRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?Ded </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?NatRels </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFFinite</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?LFFiniteBase </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?EnumCoprodRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Coproducts?LFCoprod </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/IntersectionTypes</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://LFIntersectionTypes.LFX.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lfrules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">typeintersection</span><span class="w"> </span><span class="p">#</span><span class="s"> 1⊓… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9999</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Rules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?TermsTypesKinds </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntersectionTypeRule </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntersectionTyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntersectionSubtypeRuleLeft </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntersectionSubtypeRuleRight </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFIntersectionTypes</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LambdaPi </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Rules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?PiType</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?PiTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule lfrules?ApplyTerm❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?LambdaTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?Beta</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?Extensionality</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?PiCongruence</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?LambdaCongruence</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?Solve</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?SolveType</span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?TheoryTypeWithLF</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?PiIntroduction</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?ForwardPiElimination</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?BackwardPiElimination</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">lfrules?LFHOAS</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ApplyIntersection </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Records</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://Records.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules2</span><span class="w"> </span><span class="s">scala://LFX.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?ModExp </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">  </span><span class="no">Rectype</span><span class="w"> </span><span class="p">#</span><span class="s"> {&#39; L1Td,… &#39;} </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Recexp</span><span class="w">  </span><span class="p">#</span><span class="s"> [&#39; L1Dd,… &#39;] </span><span class="k">prec</span><span class="w"> </span><span class="mi">-12000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Getfield</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 . L2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ModelsOf</span><span class="w"> </span><span class="p">#</span><span class="s"> Mod 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// ModelsOfUnary # Mod 1 prec -999 ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// AsInstance # AsInstance 1 prec -1000 ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">RecordMerge</span><span class="w"> </span><span class="p">#</span><span class="s"> 1⊕… </span><span class="k">prec</span><span class="w"> </span><span class="mi">0</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Rules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?GetFieldComp </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule rules?GetFieldInType ❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?GetfieldTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecEquality </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecExpCongruence </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecordExpTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecordTypeTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecSubtype </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecTypeCheck </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecTypeCongruence </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?CanonicalSolution</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule rules?ModelsRule ❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ModelsInference </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ModelsChecking </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Instance </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ExtendInstance </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecordMergeInference </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MergeCheck </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedRecords</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?TermsTypesKinds </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Rules </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFRecords</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedRecords </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Sigma</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://Sigma.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">Sigma</span><span class="w">   </span><span class="p">#</span><span class="s"> Σ V1T,… . 2   </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">Product</span><span class="w"> </span><span class="p">#</span><span class="s"> 1×…           </span><span class="k">prec</span><span class="w">  </span><span class="mi">-9990</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">Tuple</span><span class="w">   </span><span class="p">#</span><span class="s"> ⟨ 1,… ⟩				</span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">Projl</span><span class="w">   </span><span class="p">#</span><span class="s"> πl 1						</span><span class="k">prec</span><span class="w"> </span><span class="mi">-900</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">Projr</span><span class="w">   </span><span class="p">#</span><span class="s"> πr 1						</span><span class="k">prec</span><span class="w"> </span><span class="mi">-900</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Rules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SigmaTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TupleTerm </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection1Term </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection2Term </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SigmaType </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SigmaEquality </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TupleEquality </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection1Beta </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection2Beta </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SigmaSubtype </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedSigma</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?TermsTypesKinds</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Rules </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFSigma</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedSigma </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Subtyping</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://Subtyping.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PiRule</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiRule </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFWithVariance</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?PiRule </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SubSymbol</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">subtypeOf</span><span class="w"> </span><span class="p">#</span><span class="s"> %n 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9996</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">SubRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SubUniverseRule </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SubUniverseType </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SubtypeOfRule </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SubtypeOfTypeRule </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFPowerTypes</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?SubSymbol </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?SubRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?LFWithVariance </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">JudgmentSymbol</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">subtypeJudge</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 &lt;* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9995</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">JudgmentRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SubJudgUniverseType </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule rules?SubJudgRule ❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFSubJudgment</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?JudgmentSymbol </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?JudgmentRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?LFWithVariance </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PredSubSymbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">predsubtp</span><span class="w"> </span><span class="p">#</span><span class="s"> ⟨ V1T | 2 ⟩ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10001</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">PredOf</span><span class="w"> </span><span class="p">#</span><span class="s"> PredOf 1 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">PredSubRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Predsubtype </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Predsubrule </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PredsubTyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PredOfTerm </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFPredSub</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?PredSubSymbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?PredSubRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?LFWithVariance </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">AllSubtypes</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// include ?SubSymbol ❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// include ?SubRules ❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?JudgmentSymbol </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?JudgmentRules </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?PredSubSymbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?PredSubRules </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFSubtyped</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?AllSubtypes </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?LFWithVariance </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/TypedHierarchy</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://TypedHierarchy.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lf</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">meta</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">TypeLevel</span><span class="w"> </span><span class="p">#</span><span class="s"> 𝒰 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">UnspecifiedTypeLevel</span><span class="w"> </span><span class="p">#</span><span class="s"> 𝒰 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-999</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Rules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypeLevelUniverse </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypeLevelSubRule </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LevelType </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedHierarchy</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">meta:?Errors</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?ModExp</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">meta:?mmt</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?Typed </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?Kinded </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?NatLiteralsOnly </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Rules </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LevelComputation </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFHierarchy</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedHierarchy </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?PLF </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiHierarchy</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LambdaHierarchy</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Polymorphism</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PolymorphismLambda </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/WTypes</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://WTypes.LFX.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">wtype</span><span class="w"> </span><span class="p">#</span><span class="s"> W V1T . 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">sup</span><span class="w"> </span><span class="p">#</span><span class="s"> sup 2 , V1 ⟹ 3 to 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-8000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">rec</span><span class="w"> </span><span class="p">#</span><span class="s"> rec 4 , V1 , V2 , V3 ⟹ 5 to 6  </span><span class="k">prec</span><span class="w"> </span><span class="mi">-8000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Rules</span><span class="w"> </span><span class="p">=</span><span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?WTypeFormation </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SupIntroduction </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?WEquality </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecElimination </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RecComputation </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// rule info.kwarc.mmt.LFX.WTypes.supEquality ❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">WTypes</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LF </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Symbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Rules </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFW</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?WTypes </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Finite?LFFinite </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Inductive</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?LFW </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Sigma?LFSigma </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InductiveTypes </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InductiveDefs </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Quote-Eval</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Symbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">Construction</span><span class="w"> </span><span class="p">#</span><span class="s"> ℰ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">quoteOp</span><span class="w"> </span><span class="p">#</span><span class="s"> ⌜ 1 ⌝ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">evalOp</span><span class="w"> </span><span class="p">#</span><span class="s"> |⌜ 1 ⌝| </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1100</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">unquoteOp</span><span class="w"> </span><span class="p">#</span><span class="s"> ⌞ 1 ⌟ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://cf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">CF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?PLF</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">instance</span><span class="w"> </span><span class="p">#</span><span class="s"> instance 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">new</span><span class="w">    </span><span class="p">#</span><span class="s"> new 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NewInstance</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">field</span><span class="w">    </span><span class="p">#</span><span class="s"> 1 . 2</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span>
<span class="w">   </span><span class="no">sequence</span><span class="w"> </span><span class="p">#</span><span class="s"> var V1;… in 2;…</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Sequence</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">None</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">none</span><span class="p">:</span><span class="w"> </span><span class="s">None</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">   </span><span class="no">assign</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 = 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Assignment</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?AssignmentTerm</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">meta</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Dedukti</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?PLF</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">rewriteType</span><span class="p">:</span><span class="w"> </span><span class="s">type ⟶ type ⟶ type</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ---&gt; 2</span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">rewriteTerm</span><span class="p">:</span><span class="w"> </span><span class="s">{a: type} a ⟶ a ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 --&gt; 2</span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w">                                   </span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://quotation.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="cm">/T   higher-order logic with quotation and evaluation, mostly following Bill Farmer&#39;s work ❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">HOLQE</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="sd"># Higher-order logic</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">   </span><span class="sd">## Types</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T the LF-type representing HOL types ❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">tp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T function types ❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">fun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp ⟶ tp ⟶ tp</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ⇒ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Normally we represent object language variables using LF variables, in which case the following is redundant.</span>
<span class="cm">      But Farmer&#39;s language follows the traditional style of assuming an infinite supply of variables at every type.</span>
<span class="cm">      It is critical to capture this in the representation because he allows quoting terms with free variables.❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the type of variables at a given HOL type❙</span><span class="w"></span>
<span class="w">   </span><span class="no">Var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp ⟶ type</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the constructor for concrete variables %x:a at a given HOL type where x is any identifier that is parsed as a closed term</span>
<span class="cm">      Most of the time, we do not need this because we can use LF-variables v:Var a as meta-variables that range over HOL variables at type a.❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">var</span><span class="w"> </span><span class="p">#</span><span class="s"> % L1T </span><span class="k">prec</span><span class="w"> </span><span class="mi">200</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the typing rule (%x:a):Var a for concrete variables cannot be expressed in LF, so we implement an MMT rule❙</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ConcreteVariable</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd">## Terms</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the LF-type representing HOL terms of a given HOL type ❙</span><span class="w">  </span>
<span class="w">   </span><span class="no">tm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp ⟶ type</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> tm 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T all variables are terms of their respective type ❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">tvar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a ⟶ tm a</span><span class="p">❘#</span><span class="s"> tvar 2</span><span class="p">❘#</span><span class="s"># 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T λ-abstraction (contrary to typical LF-encodings, we bind explicit variables that have to be injected into terms using tvar ❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, b} (Var a ⟶ tm b) ⟶ tm a ⇒ b</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> λ 3</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T application ❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, b} tm a ⇒ b ⟶ tm a ⟶ tm b</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 @ 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T undefined terms (not needed here, but probably needed later on when evaluating quotations of ill-typed terms❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">undefined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm a</span><span class="p">❘#</span><span class="s"> ⊥ 1</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T booleans, connectives, and proofs❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">bool</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tp</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">equal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm a ⟶ tm a ⟶ tm bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 = 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">ded</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tm bool ⟶ type</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ⊦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd"># Quotation</span><span class="p">❙</span><span class="w"> </span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T We add HOL types that reify HOL concepts❙</span><span class="w"> </span>

<span class="w">   </span><span class="sd">## Quoting Terms</span><span class="p">❙</span><span class="w"> </span>

<span class="w">   </span><span class="cm">/T We add a type holding quotations of HOL terms. All terms may be quoted, including ill-typed ones.</span>
<span class="cm">      Effectively, this amounts to having a type that represents the untype λ-calculus inside a typed λ-calculus.❙</span><span class="w"> </span>

<span class="w">   </span><span class="sd">### Syntax</span><span class="p">❙</span><span class="w">    </span>
<span class="w">      </span>
<span class="w">   </span><span class="cm">/T the type of quoted terms❙</span><span class="w"></span>
<span class="w">   </span><span class="no">qtp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tp </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ε</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted variables❙</span><span class="w"></span>
<span class="w">   </span><span class="no">qvar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a ⟶ tm ε</span><span class="p">❘#</span><span class="s"> qvar 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">❘#</span><span class="s"># qvar 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted λ-abstractions❙</span><span class="w"></span>
<span class="w">   </span><span class="no">qlam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a ⟶ tm ε ⟶ tm ε </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> qlam 2 . 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">150</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted applications❙</span><span class="w"></span>
<span class="w">   </span><span class="no">qapp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tm ε ⟶ tm ε ⟶ tm ε </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> qapp 1 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T quoted quotations❙</span><span class="w"></span>
<span class="w">   </span><span class="no">qquote</span><span class="p">:</span><span class="w"> </span><span class="s">tm ε ⟶ tm ε</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Finally, we add a meta-level operation that turns a term into the corresponding quotation.</span>
<span class="cm">      We may think of it as having type ${a}tm a ⟶ tm ε$ except. However, quotation may not be subject to congruence and therefore cannot have an LF type.❙</span><span class="w">   </span>
<span class="w">   </span><span class="no">quote</span><span class="w"> </span><span class="p">#</span><span class="s"> ⌜ 1 ⌝  </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the rule that eliminates occurrences of quote by constructing the corresponding term of type $tm ε$</span>
<span class="cm">      HOL variables in the argument are quoted using $qvar$, LF variables remain, which gives rise to quasi-quotation.❙</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteTerm</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="sd">### Semantics</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T the predicate expressing that a term is the quotation of a term of a given types.❙</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">tm ε ⟶ tp ⟶ tm bool</span><span class="p">❘#</span><span class="s"> 1 $ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted variables❙</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,v: Var a} ⊦ qvar v $ a</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted λ-abstractions❙</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b,v:Var a,E} ⊦ E $ b ⟶ ⊦ qlam v.E $ a ⇒ b</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted applications❙</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b,F,E} ⊦ F $ a ⇒ b ⟶ ⊦ E $ a ⟶ ⊦ qapp F E $ a ⇒ b</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T typing rule for quoted quotations❙</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype_quote</span><span class="p">:</span><span class="w"> </span><span class="s">{E,a} ⊦ E $ a ⟶ ⊦ qquote E $ ε</span><span class="p">❙</span><span class="w">   </span>

<span class="w">   </span><span class="sd">## Quoting Substitutions</span><span class="p">❙</span><span class="w"> </span>

<span class="w">   </span><span class="cm">/T Expanding on Farmer&#39;s work, we also add a type holding HOL substitutions.</span>
<span class="cm">      Effectively, this amounts to a language with explicit substitutions.</span>
<span class="cm">      Because all variables are always in scope, every substitution maps all variables to terms.❙</span><span class="w"> </span>

<span class="w">   </span><span class="sd">### Syntax</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the type of substitutions❙</span><span class="w"></span>
<span class="w">   </span><span class="no">stp</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tp</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> sub</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the identity substitutions❙</span><span class="w"></span>
<span class="w">   </span><span class="no">idsub</span><span class="p">:</span><span class="w"> </span><span class="s">tm sub</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the substitution that modifies a given substitution in one place❙</span><span class="w"></span>
<span class="w">   </span><span class="no">update</span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm sub ⟶ Var a ⟶ tm a ⟶ tm sub </span><span class="p">❘#</span><span class="s"> 2 + 3 ↦ 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">50</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T abbreviation for the substitution that maps one variable❙</span><span class="w">   </span>
<span class="w">   </span><span class="no">singlesub</span><span class="p">:</span><span class="w"> </span><span class="s">{a} Var a ⟶ tm a ⟶ tm sub </span><span class="p">❘#</span><span class="s"> 2 ↦ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">51</span><span class="p">❘</span><span class="w"></span>
<span class="w">            </span><span class="p">=</span><span class="w"> </span><span class="s">[a,v,t] idsub + v ↦ t</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T Finally, we add a meta-level operation that turns a substitution into the corresponding quotation.❙</span><span class="w">   </span>
<span class="w">   </span><span class="no">subs</span><span class="w"> </span><span class="p">#</span><span class="s"> ` L1T,… ´  </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the rule that eliminates occurrences of subs by constructing the corresponding term of type $tm sub$❙</span><span class="w"> </span>
<span class="w">   </span><span class="cm">// rule rules?QuoteSubs❙</span><span class="w"></span>

<span class="w">   </span><span class="sd">### Semantics</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T an auxiliary predicate to reason about inequality of variables❙</span><span class="w"></span>
<span class="w">   </span><span class="no">diff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b} Var a ⟶ Var b ⟶ tm bool </span><span class="p">❘#</span><span class="s"> 3 ≠ 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">10</span><span class="p">❙</span><span class="w"> </span><span class="cm">// notation parsing errors not reported correctly? ❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the function that retrieves the map of a variable by a substitution❙</span><span class="w"></span>
<span class="w">   </span><span class="no">lookup</span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm sub ⟶ Var a ⟶ tm a </span><span class="p">❘#</span><span class="s"> 3 &#39; 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">15</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for the identity substitution❙</span><span class="w">   </span>
<span class="w">   </span><span class="no">subst_id</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{a,v: Var a} ⊦ v&#39;idsub = (tvar v)</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for an update to the needed variables❙</span><span class="w">   </span>
<span class="w">   </span><span class="no">subst_update_same</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,a, v: Var a, E} ⊦ v&#39;(s+v↦E) = E</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the lookup rule for an update to some other variable❙</span><span class="w">   </span>
<span class="w">   </span><span class="no">subst_update_diff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,a,b, v: Var a, w: Var b, E} ⊦ v ≠ w ⟶ ⊦ v&#39;(s+w↦E) = v&#39;s</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="sd"># Evaluation</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T Evaluation internalizes the model-theoretical semantics: evaluation takes a term and a substitution (which provides the assignment to the free variables) and returns its interpretation in the model.</span>
<span class="cm">   </span>
<span class="cm">   Evaluation is only defined for quotations of well-typed terms. Because the type of a quotation is not stored in the quotation,</span>
<span class="cm">   * evaluation takes a HOL-type as an additional argument,</span>
<span class="cm">   * evaluation rules take typing assumptions.❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T the evaluation operator❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eval</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{a} tm ε ⟶ tm sub ⟶ tm a </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ⟦ 2 $ 1 ⟧ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"># ⟦ 2 $ 1 ⟧ ^ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for variables: apply the assignment❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_var</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, v: Var a, s} ⊦ (⟦qvar v $ a⟧s) = v&#39;s</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for λ-abstractions qlam v.E: build the function that maps x to the evaluation of E under the assignment of v to x❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_fun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a, b, v: Var a, E, s} ⊦ E $ b ⟶ ⊦ (⟦qlam v.E $ a ⇒ b⟧s) = λ[x](⟦E $ b⟧ s + v ↦ tvar x)</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for applications: straightforward❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b, F, X, s} ⊦ F $ a ⇒ b  ⟶  ⊦ X $ a  ⟶  ⊦ (⟦qapp F X $ b⟧s) = (⟦F $ a ⇒ b⟧s) @ ⟦X $ a⟧s</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T the evaluation rule for quotations: evaluation cancels quotation❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eval_quote</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X, s} ⊦ X $ ε  ⟶  ⊦ (⟦qquote X $ ε⟧s) = X</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
<span class="cm">/T Now we formalize two challenge problems posed by Farmer❚</span><span class="w"></span>
<span class="w"> </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">ExcludedMiddle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?HOLQE</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">not</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tm bool ⟶ tm bool</span><span class="p">❘#</span><span class="s"> ¬ 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">or</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">tm bool ⟶ tm bool ⟶ tm bool</span><span class="p">❘#</span><span class="s"> 1 ∨ 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">em</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{f,s} ⊦ f $ bool ⟶ ⊦ (⟦f$bool⟧s) ∨ ¬ ⟦f$bool⟧s </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PolyDiff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?HOLQE</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T real numbers and derivatives❙</span><span class="w"></span>
<span class="w">  </span><span class="no">R</span><span class="p">:</span><span class="w"> </span><span class="s">tp</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">derivative</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">tm R ⇒ R ⟶ tm R ⇒ R</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T a transformer that computes the derivative of a polynomial and its meaning formula❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ispolyin</span><span class="p">:</span><span class="w"> </span><span class="s">tm ε ⟶ Var R ⟶ tm bool</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">polyderiv</span><span class="p">:</span><span class="w"> </span><span class="s">tm ε ⟶ Var R ⟶ tm ε</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">meaning</span><span class="p">:</span><span class="w"> </span><span class="s">{v, p} ⊦ ispolyin p v ⟶ ⊦ derivative (λ[x] ⟦p $ R⟧v ↦ tvar x) = (λ[x] ⟦polyderiv p v $ R⟧v ↦ tvar x) </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://intersection.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="cm">/T   A representation of intersection types in MMT, following &quot;Towards a Logical Framework with Intersection and Union Types&quot; by Stolze, Liquori, Honsell, Scagnetto.❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Intersection</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T intersection type❙</span><span class="w"></span>
<span class="w">   </span><span class="no">inter</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ∩ 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T elements of an intersection type❙</span><span class="w"></span>
<span class="w">   </span><span class="no">pair</span><span class="w"> </span><span class="p">#</span><span class="s"> ⟨ 1 , 2 ⟩ </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T projections from an intersection type❙</span><span class="w"></span>
<span class="w">   </span><span class="no">project1</span><span class="w"> </span><span class="p">#</span><span class="s"> proj1 1 </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">project2</span><span class="w"> </span><span class="p">#</span><span class="s"> proj2 1 </span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InterTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PairTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection1Term</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Projection2Term</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InterTyping</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InterEqual</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">IntersectionTest</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?Intersection</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">  </span><span class="no">a</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">b</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T auto-application ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">test</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">((a ⟶ b) ∩ a) ⟶ b</span><span class="p">❘</span><span class="w"></span>
<span class="w">       </span><span class="p">=</span><span class="w"> </span><span class="s">[x] (proj1 x) (proj2 x)</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T This is a negative test: it should fail with an error that $(a ⟶ b)∩(a ⟶ b)$ is not equal to $(a ⟶ b)∩a$.❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// test2 = test test❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Isabelle</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt?Errors❚</span>
<span class="s">   include ?PLF</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">prop</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">prop ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ⊦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">0</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">proof</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">meta</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt</span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Typed</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype</span><span class="w">   </span><span class="p">#</span><span class="s"> : 1 </span><span class="k">prec</span><span class="w">  </span><span class="mi">-9995</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">equality</span><span class="w"> </span><span class="p">#</span><span class="s"> equality 1 2  </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">typeAttribution</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 : 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9997</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">OMLType</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">defAttribution</span><span class="w">  </span><span class="p">#</span><span class="s"> 1 := 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9998</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">OMLDef </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">notationAttribution</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 # 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9998</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">OMLNotation </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Kinded</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed</span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">kind</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedConstants</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UniverseType</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypeInhabitable </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">KindedConstants</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UniverseKind</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?KindInhabitable </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TermsTypesKinds</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">meta:?Errors</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?ModExp</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">meta:?mmt</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Kinded </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?TypedConstants </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?KindedConstants </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnivTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypeAttributionTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?DropTypeAttribution</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LambdaPi</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Kinded</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">Pi</span><span class="w">     </span><span class="p">#</span><span class="s"> { V1T,… } 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">lambda</span><span class="w"> </span><span class="p">#</span><span class="s"> [ V1T,… ] 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">apply</span><span class="w">  </span><span class="p">#</span><span class="s"> 1%w…        </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">arrow</span><span class="w">  </span><span class="p">#</span><span class="s"> 1⟶…         </span><span class="k">prec</span><span class="w">  </span><span class="mi">-9990</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFRules</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LambdaPi</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiType</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ApplyTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LambdaTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Beta</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Extensionality</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiCongruence</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LambdaCongruence</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NormalizeCurrying</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Solve</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SolveType</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TheoryTypeWithLF</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiIntroduction</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ForwardPiElimination</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?BackwardPiElimination</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PiIrrelevanceRule</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LFHOAS</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LambdaPi </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LFRules </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">ShallowPolymorphism</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ShallowPolymorphism</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PolymorphicApplyTerm </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?ShallowPolymorphism</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFModulo</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">equality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type} A ⟶ A ⟶ type </span><span class="p">❘#</span><span class="s"> 2 = 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9000</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w">                                                                              </span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="cm">/T LLF_P as introduced by Honsell, Liquori, Maksimovi, Scagnetto in</span>
<span class="cm">A logical framework for modeling external evidence, side conditions, and proof irrelevance using monads❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://externals.lf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Locks</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="cm">// Lp p a b &lt;T&gt; is the type \mathcal{L}^p_{a,b}[T] from the paper.❙</span><span class="w"></span>
<span class="w">   </span><span class="no">locktype</span><span class="w"> </span><span class="p">#</span><span class="s"> Lp 1 2 3 &lt; 4 &gt; </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// Lm p a b &lt;t&gt; is the term \mathcal{L}^p_{a,b}[t] from the paper.❙</span><span class="w"></span>
<span class="w">   </span><span class="no">lockterm</span><span class="w"> </span><span class="p">#</span><span class="s"> Lm 1 2 3 &lt; 4 &gt; </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// U &lt;t&gt; for t:Lp p a b &lt;T&gt; is the term \mathcal{U}^p_{a,b}[t] from the paper.</span>
<span class="cm">      U is unary here because p, a, and b can be inferred from t.❙</span><span class="w"></span>
<span class="w">   </span><span class="no">unlock</span><span class="w"> </span><span class="p">#</span><span class="s"> U &lt; 1 &gt; </span><span class="p">❙</span><span class="w">                                           </span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// Convenience operator to bundle p, a, b into a single object.</span>
<span class="cm">   key # K 1 2 3❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">// The typing rules.❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InferLockType</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InferLockTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InferUnlock</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TypingLock</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EqualityLock</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnlockLock</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LLFP</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Locks</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">CallByValueExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LLFP</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="cm">/T following Section 5.1 of the paper: call-by-value reduction ❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T untyped λ calculus ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">term</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">app</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">term ⟶ term ⟶ term </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 @ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">50</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">lam</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">(term ⟶ term) ⟶ term</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> λ 1</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T natural numbers ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">z</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">S</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat ⟶ nat</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T free variables using natural numbers❙</span><span class="w"></span>
<span class="w">   </span><span class="no">free</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat ⟶ term</span><span class="p">❘#</span><span class="s"> &#39; 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T equality judgment and its rules ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">term ⟶ term ⟶ type</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ≐ 2 </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Judgment</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M} M ≐ M</span><span class="p">❘#</span><span class="s"> refl 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">symm</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N} M ≐ N ⟶ N ≐ M</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">trans</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N,P} M ≐ N ⟶ N ≐ P ⟶ M ≐ P</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eq_app</span><span class="p">:</span><span class="w"> </span><span class="s">{M,N,X,Y} M ≐ N ⟶ X ≐ Y ⟶ M@X ≐ N@Y</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> eq_app 5 6</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T We declare a single constant Val for the side condition and one rule that implements it.</span>
<span class="cm">      The condition Val N term checks if N:term is an abstraction or a free variable ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">Val</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ValRule</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T reduction rules using Val condition❙</span><span class="w"></span>
<span class="w">   </span><span class="no">betav</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N} Lp Val N term &lt;(λ M)@N ≐ (M N)&gt;</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> betav 1 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">csiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{M,N}({x} Lp Val x term &lt;(M x) ≐ (N x)&gt;) ⟶ (λ M) ≐ (λ N)</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> csiv 3</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">/T example from the end of the section ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">t1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">λ[x] &#39;z @ ((λ[y] y) @ x)</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">t2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">λ[x] &#39;z @ x</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">goal</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">t1 ≐ t2</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T The following check succeeds without ever calling the ValRule because the unlock is under a lock.❙</span><span class="w"></span>
<span class="w">   </span><span class="no">check</span><span class="p">:</span><span class="w"> </span><span class="s">goal </span><span class="p">❘</span><span class="w"></span>
<span class="w">     </span><span class="p">=</span><span class="w"> </span><span class="s">csiv [x] Lm Val x term &lt;</span>
<span class="s">       eq_app (refl &#39;z) U&lt;betav ([y] y) x&gt;</span>
<span class="s">     &gt;</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T The following example does not guard the unlock but still succeeds because &#39;n is indeed a value.❙</span><span class="w"></span>
<span class="w">   </span><span class="no">check2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[n] eq_app (refl &#39;z) U&lt;betav ([y] y) &#39;n&gt;</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">/T The following negative example fails because x is any term and thus not necessarily a value.❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// fail   = [x] eq_app (refl &#39;z) U&lt;betav ([y] y) x&gt;❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/mmt</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://api.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Errors</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="cm">// a missing term of a given type ❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">missing</span><span class="w">   </span><span class="p">#</span><span class="s"> ≪ 1 ≫        </span><span class="k">prec</span><span class="w"> </span><span class="mi">-99500</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// a term not matching a required type ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">illtyped</span><span class="w">  </span><span class="p">#</span><span class="s"> ≪ 1 :: 2 ≫   </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100000</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// an unknown term (e.g., an omitted proof) that uses certain subterms (e.g., the used axioms) ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">unknown</span><span class="w">   </span><span class="p">#</span><span class="s"> ≪ using 1,… ≫ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100003</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">// this notation clashes with unbracketed lambdas inside some other unknown, removed for now</span>
<span class="cm">   // unsolved  # ≪ [ V1T,… ] 2 ≫ prec -100006❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// an ambiguous term with multiple options; its first argument is the number of the argument that was obtained as the result of disambiguation (starting from 0) ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">oneOf</span><span class="w">     </span><span class="p">#</span><span class="s"> ≪ 1 @ 2,… ≫ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100002</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// infers the type of missing terms❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/checking?HoleTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// reduces disambiguated term ❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/checking?Disambiguation</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// disambiguates terms formed by oneOf ❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/checking?InferAmbiguous</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">mmt</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">   </span><span class="cm">// binds unsolved meta-variables ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">unknown</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// binds free variables that are implicitly quantified at the toplevel❙</span><span class="w"></span>
<span class="w">   </span><span class="no">free</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// the type of all rules❙</span><span class="w"></span>
<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">rule</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/parser?GenericEscapeLexer</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// rule info.kwarc.mmt.api.parser?UnicodeReplacer❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/parser?MMTURILexer</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// the type of notations❙</span><span class="w"></span>
<span class="w">   </span><span class="no">notation</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// enables notation literals❙</span><span class="w"> </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/notations?NotationRealizedType</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/patterns?PatternFeature</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/patterns?InstanceFeature</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">// notations with round brackets must have a lower precedence than this to be recognized ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">brackets</span><span class="w">     </span><span class="p">#</span><span class="s"> ( 1 ) </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000005</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// left bracket with omitted partner as far to the right as consistent with round brackets ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">andrewsDot</span><span class="w">   </span><span class="p">#</span><span class="s"> ▪ 1  </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// right bracket with omitted partner as far to the left as consistent with round brackets ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">andrewsDotRight</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ▫  </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="no">oftype</span><span class="w">   </span><span class="p">#</span><span class="s"> : 1</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">List</span><span class="w">     </span><span class="p">#</span><span class="s"> List 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">list</span><span class="w">     </span><span class="p">#</span><span class="s"> [ 1,… ]</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Option</span><span class="w">   </span><span class="p">#</span><span class="s"> Option 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">some</span><span class="w">     </span><span class="p">#</span><span class="s"> some 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">none</span><span class="w">     </span><span class="p">#</span><span class="s"> none</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Tuple</span><span class="w">    </span><span class="p">#</span><span class="s"> 1×…</span><span class="p">❙</span><span class="w"> </span>
<span class="w">   </span><span class="no">tuple</span><span class="w">    </span><span class="p">#</span><span class="s"> ⟨ 1,… ⟩ </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">proj</span><span class="w">     </span><span class="p">#</span><span class="s"> 1 . 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Function</span><span class="w"> </span><span class="p">#</span><span class="s"> 1×… ⟶ 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">lambda</span><span class="w">   </span><span class="p">#</span><span class="s"> λ V1T,… . -2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">apply</span><span class="w">    </span><span class="p">#</span><span class="s"> 1@…</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Nat</span><span class="w">   </span><span class="p">#</span><span class="s"> ℕ</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">plus</span><span class="w">  </span><span class="p">#</span><span class="s"> 1+…</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">times</span><span class="w"> </span><span class="p">#</span><span class="s"> 1*…</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">minus</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 - 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">div</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 / 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">less</span><span class="w">      </span><span class="p">#</span><span class="s"> 1 &lt; 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">lesseq</span><span class="w">    </span><span class="p">#</span><span class="s"> 1 ≤ 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">greater</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 &gt; 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">greatereq</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ≥ 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">Boolean</span><span class="w"> </span><span class="p">#</span><span class="s"> ℬ</span>
<span class="s">   and     # 1∧…</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">or</span><span class="w">      </span><span class="p">#</span><span class="s"> 1∨…</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">equal</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 = 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">ifte</span><span class="w">    </span><span class="p">#</span><span class="s"> if ( 1 ) 2 else 3</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">match</span><span class="w">   </span><span class="p">#</span><span class="s"> 1 match 2|… </span><span class="k">prec</span><span class="w"> </span><span class="mi">50</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">case</span><span class="w">    </span><span class="p">#</span><span class="s"> [ V2T,… ] 1 ⇝ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://moduleexpressions.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ModExp</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">theory</span><span class="w">   </span><span class="p">#</span><span class="s"> THY</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kd">constant</span><span class="w"> </span><span class="no">morphism</span><span class="w"> </span><span class="p">#</span><span class="s"> MOR 1 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">complextheory</span><span class="w">   </span><span class="p">#</span><span class="s"> {| L1Td,… |} </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000005</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">complexmorphism</span><span class="w"> </span><span class="p">#</span><span class="s"> [| L1D,… |] </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000005</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">identity</span><span class="w">        </span><span class="p">#</span><span class="s"> IDENTITY 1   </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">composition</span><span class="w">     </span><span class="p">#</span><span class="s"> COMPOSE 1;… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">// morphismapplication # %L2d!_1 APPLY 2❙</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TheoryTypeInhabitable</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TheoryTypeUniverse</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphTypeInhabitable</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComplexTheoryInfer</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?AnonymousTheoryInfer</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphCheck</span><span class="p">❙</span><span class="w">     </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphismApplicationTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?MorphismApplicationCompute</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Combinators</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?ModExp</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">empty</span><span class="w"> </span><span class="p">#</span><span class="s"> EMPTY 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">extends</span><span class="w">  </span><span class="p">#</span><span class="s"> 1 EXTEND { %L1_L2,… } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">rename1</span><span class="w"> </span><span class="p">#</span><span class="s"> L1 ⟿ L2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-500000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">rename</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 RENAME { 2,… } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">combine</span><span class="w">  </span><span class="p">#</span><span class="s"> COMBINE 1 { 2,… } 3 { 4,… } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-2000000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">translate</span><span class="w"> </span><span class="p">#</span><span class="s"> MIXIN 1 { 2,… } 3 { 4,… } </span><span class="k">prec</span><span class="w"> </span><span class="mi">-2000000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeEmpty </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeExtends </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeRename </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ComputeCombine </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?ComputeMixin ❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFComb</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Combinators</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://www.openmath.org/cd</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">OpenMath</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">Object</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">mapsto</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">naryObject</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">binder</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">OMI</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// the lexing and checking rule for integer literals, e.g., 1 ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule info.kwarc.mmt.api.objects?OMI❙</span><span class="w"></span>
<span class="w">  </span><span class="no">OMF</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// the lexing and checking rule for floating point literals ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule info.kwarc.mmt.api.objects?OMF❙</span><span class="w"></span>
<span class="w">  </span><span class="no">OMSTR</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// the lexing and checking rule for string literals, e.g., &quot;1&quot; ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// rule info.kwarc.mmt.api.objects?OMSTR❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">lf</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Bool</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">BOOL</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">TRUE</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">BOOL</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">FALSE</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">BOOL</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Bool </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">DED</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">BOOL ⟶ type</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> DED 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Judgment</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">lf?TermIrrelevanceRule (DED)</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">lf?PiIrrelevanceRule </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">TRUEI</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">DED TRUE</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">//   dependently-typed higher-order logic, i.e., LF with booleans and equality❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">DHOL</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Ded </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">EQUAL</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a:type} a ⟶ a ⟶ BOOL </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 EQ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Eq</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">NOTEQUAL</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a:type} a ⟶ a ⟶ BOOL </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 NEQ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">CONTRA</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❘=</span><span class="w"> </span><span class="s">DED FALSE</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="cm">// if : {a:type} bool ⟶ a ⟶ a ⟶ a❙</span><span class="w"></span>

<span class="w">  </span><span class="no">REFL</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A} DED X EQ X  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">SYM</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A,Y} DED X EQ Y ⟶ DED Y EQ X </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">TRANS</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A,Y,Z} DED X EQ Y ⟶ DED Y EQ Z ⟶ DED X EQ Z </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">CONG</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, B, F: A ⟶ B, X, Y: A} DED X EQ Y ⟶ DED (F X) EQ (F Y)</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">DHOL2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">bool</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">equal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type} A ⟶ A ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 ≐ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">ded</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ⊦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">refl</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{A,X:A} ⊦ X ≐ X </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> refl %I1 %I2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">cong</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, B: type} {F: A ⟶ B} {X, Y: A} ⊦ X ≐ Y ⟶ ⊦ (F X) ≐ (F Y) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> congI 3 6 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type,B:A ⟶ type}{F:{x:A} B x, G:{x:A} B x} ({x: A} ⊦ F x ≐ G x) ⟶ ⊦ F ≐ G </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ext 5 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">eqDed</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{B1,B2:bool} ⊦ B1 ≐ B2 ⟶ ⊦ B1 ⟶ ⊦ B2 </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> eqded 3 4</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">eqI</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{B1,B2:bool} (⊦ B1 ⟶ ⊦ B2) ⟶ (⊦ B2 ⟶ ⊦ B1) ⟶ ⊦ (B1 ≐ B2) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> eqI 3 4 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">symmetry</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type}{a,b : A} ⊦ a ≐ b ⟶ ⊦ b ≐ a </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A][a,b][p] eqded (congI ([x] x ≐ a) p) refl </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> symm 4 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">eqFun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type,B : type}{F,G : A ⟶ B} ⊦ F ≐ G ⟶ {a} ⊦ F a ≐ G a </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B][F,G][p][a] congI ([H: A ⟶ B] H a) p </span><span class="p">❘#</span><span class="s"> eqfun 5 6 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">([x:bool] x) ≐ ([x:bool] x) </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">trueI</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">⊦ true </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">refl </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">forall</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type} (A ⟶ bool) ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P] P ≐ ([x:A] true) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∀ 2 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">forallI</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type, P : A ⟶ bool}({x} ⊦ P x) ⟶ ⊦ ∀[x] P x </span><span class="p">❘</span><span class="w"></span>
<span class="w">    </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P][p] ext ([x: A] eqI ([pf: ⊦ P x] trueI) ([pt: ⊦ true] p x)) </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">forallE</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:type, P : A ⟶ bool} (⊦ ∀[x]P x) ⟶ {a} ⊦ P a </span><span class="p">❘</span><span class="w"></span>
<span class="w">    </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P][p][a] eqded (eqfun (symm p) a) trueI </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatSymbols</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">NAT</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">zero</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">NAT </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatArith</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatSymbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">succ</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">NAT ⟶ NAT      </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">one</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">NAT             </span><span class="p">❘</span><span class="w"></span>
<span class="w">        </span><span class="p">=</span><span class="w"> </span><span class="s">succ zero           </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">NAT ⟶ NAT ⟶ NAT </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">times</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">NAT ⟶ NAT ⟶ NAT </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatRels</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?Ded</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatArith </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">LEQ</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">NAT ⟶ NAT ⟶ BOOL </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 LEQ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">LESS</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">NAT ⟶ NAT ⟶ BOOL </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 LESS 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">5</span><span class="p">❘</span><span class="w"></span>
<span class="w">        </span><span class="p">=</span><span class="w"> </span><span class="s">[m,n] (succ m) LEQ n</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">REFL</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{n} DED n LEQ n</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatRules</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DHOL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatRels </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">eq_leq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X EQ Y ⟶ DED Y LEQ Z ⟶ DED X LEQ Z  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y ⟶ DED Y EQ Z ⟶ DED X LEQ Z  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">plus_comm</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED plus X Y EQ plus Y X  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_assoc</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED plus (plus X Y) Z EQ plus X (plus Y Z) </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_neut_Ex</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED plus X zero EQ X </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> %%prefix 0 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_neut</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED plus X zero EQ X </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[X] plus_neut_Ex X </span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">plus_succ_R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED plus X (succ Y) EQ succ (plus X Y)</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_succ_L</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED plus (succ X) Y EQ succ (plus X Y) </span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">times_comm</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED times X Y EQ times Y X  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">times_assoc</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED times (times X Y) Z EQ times X (times Y Z)  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">times_neut</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED times X one EQ X</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">times_zero</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED times X zero EQ zero</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">times_succ_R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED times X (succ Y) EQ plus (times X Y) X</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">times_succ_L</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED times (succ X) Y EQ plus (times X Y) X</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">distrib</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED times X (plus Y Z) EQ plus (times X Y) (times X Z) </span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Simplify</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">leq_refl</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED X LEQ X  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_trans</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y ⟶ DED Y LEQ Z ⟶ DED X LEQ Z    </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_antisym</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED X LEQ Y ⟶ DED Y LEQ X ⟶ DED X EQ Y      </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">plus_mono</span><span class="w">     </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y ⟶ DED (plus X Z) LEQ (plus Y Z)  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_mono_L</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y ⟶ DED (plus Z X) LEQ (plus Z Y)  </span><span class="p">❘</span><span class="w"> </span>
<span class="w">                </span><span class="p">=</span><span class="w"> </span><span class="s">[X,Y,Z,p] leq_eq (eq_leq plus_comm (plus_mono p)) plus_comm</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus_invmono</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED (plus X Z) LEQ (plus Y Z) ⟶ DED X LEQ Y  </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="kd">theory</span><span class="w"> </span><span class="nv">NatOnly</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DHOL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="no">least</span><span class="w">         </span><span class="p">:</span><span class="w"> </span><span class="s">{X} DED zero LEQ X </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">plus_larger_L</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED X LEQ (plus X Y)  </span><span class="p">❘</span><span class="w"></span>
<span class="w">                  </span><span class="p">=</span><span class="w"> </span><span class="s">[X][Y] eq_leq (SYM plus_neut) (plus_mono_L least)  </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">plus_larger_R</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y} DED Y LEQ (plus X Y)  </span><span class="p">❘</span><span class="w"></span>
<span class="w">                  </span><span class="p">=</span><span class="w"> </span><span class="s">[X][Y] leq_eq plus_larger_L plus_comm</span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">times_mono</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED X LEQ Y ⟶ DED (times X Z) LEQ (times Y Z)  </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">times_invmono</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X,Y,Z} DED (times X Z) LEQ (times Y Z) ⟶ DED X LEQ Y  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="p">❚</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">uom</span><span class="w"> </span><span class="s">scala://uom.api.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">NatLiteralsOnly</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatSymbols </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize NAT uom?StandardNat</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize zero uom?Arithmetic/Zero</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">    </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">NatLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatLiteralsOnly </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatArith</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize one uom?Arithmetic/One</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Realize succ uom?Arithmetic/Succ</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DHOL</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatSymbols</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatRules</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatRules/NatOnly</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatLiterals</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/qmt</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTTypes</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">query</span><span class="w">  </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">prop</span><span class="w">   </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">basetp</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">tp</span><span class="w">     </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTQuery</span><span class="w"> </span><span class="p">=</span><span class="w">	</span>
<span class="w">	</span><span class="cm">// Precedence -16xxxx❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// &lt;&lt;left&gt;&gt; union|intersection|difference &lt;&lt;right&gt;&gt; ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Union</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 or 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-169000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Intersection</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 and 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-169000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Difference</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 but not 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-169000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">Tuple</span><span class="w"> </span><span class="p">#</span><span class="s"> (* 1,… *) </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Projection</span><span class="w"> </span><span class="p">#</span><span class="s">  L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// binders ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Let</span><span class="w"> </span><span class="p">#</span><span class="s"> let V1 := 2 in 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Mapping</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 map V1 *=&gt;* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">BigUnion</span><span class="w"> </span><span class="p">#</span><span class="s"> &lt;* 3 | V1 in 2 *&gt; </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Comprehension</span><span class="w"> </span><span class="p">#</span><span class="s"> {* V1 in 2 | 3 *} </span><span class="k">prec</span><span class="w"> </span><span class="mi">-168000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// select [from &lt;&lt;start&gt;&gt; until &lt;&lt;end&gt;&gt;]|&lt;&lt;index&gt;&gt; of &lt;&lt;query&gt;&gt;❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Slice</span><span class="w"> </span><span class="p">#</span><span class="s"> select from L1 until L2 of 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160004</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">SliceFrom</span><span class="w"> </span><span class="p">#</span><span class="s"> select from L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160003</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">SliceUntil</span><span class="w"> </span><span class="p">#</span><span class="s"> select until L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160002</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Element</span><span class="w"> </span><span class="p">#</span><span class="s"> select L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160001</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// component|subobject &lt;&lt;spec&gt;&gt; of &lt;&lt;query&gt;&gt;❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Component</span><span class="w"> </span><span class="p">#</span><span class="s"> component L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">SubObject</span><span class="w"> </span><span class="p">#</span><span class="s"> subobject L1 of 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">I</span><span class="w"> </span><span class="p">#</span><span class="s"> use L1 for 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Closure</span><span class="w"> </span><span class="p">#</span><span class="s"> closure of 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Singleton</span><span class="w"> </span><span class="p">#</span><span class="s"> {* 1 *} </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// related to &lt;&lt;query&gt;&gt; by &lt;&lt;relation&gt;&gt;❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Related</span><span class="w"> </span><span class="p">#</span><span class="s"> related to 1 by 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// leaf case ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Literal</span><span class="w"> </span><span class="p">#</span><span class="s"> literal 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Literals</span><span class="w"> </span><span class="p">#</span><span class="s"> literals 1,… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Paths</span><span class="w"> </span><span class="p">#</span><span class="s"> paths 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">QueryFunctionApply</span><span class="w"> </span><span class="p">#</span><span class="s"> function L1 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-160000</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTJudgements</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// Precedence -15xxxx❙</span><span class="w"></span>
<span class="w">		</span>
<span class="w">	</span><span class="cm">/T Equality of two terms ❙</span><span class="w"> </span>
<span class="w">	</span><span class="no">Equals</span><span class="w"> </span><span class="p">#</span><span class="s"> V1 2 *==* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-150000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T One type has a specific term ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Types</span><span class="w"> </span><span class="p">#</span><span class="s"> V1 2 *:* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-150000</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTProp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// Precedence -14xxxx❙</span><span class="w">	</span>

<span class="w">	</span><span class="cm">/T unary type relation ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsA</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 isa L2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T ancestor relation between paths ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">PrefixOf</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *&lt;&lt;* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T element relation between elements and sets ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsIn</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 contains 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T emptiness of a set ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsEmpty</span><span class="w"> </span><span class="p">#</span><span class="s"> empty 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T equality of elements ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Equal</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *=* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T negation ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Not</span><span class="w"> </span><span class="p">#</span><span class="s"> *!* 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T And ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">And</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *&amp;&amp;* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Or ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Or</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *||* 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Forall ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Forall</span><span class="w"> </span><span class="p">#</span><span class="s"> forall V1 in 2 *.* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Exists ❙</span><span class="w"> </span>
<span class="w">	</span><span class="no">Exists</span><span class="w"> </span><span class="p">#</span><span class="s"> exists V1 in 2 *.* 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T Holds ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Holds</span><span class="w"> </span><span class="p">#</span><span class="s"> holds 1 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140000</span><span class="p">❙</span><span class="w"> </span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTRelationExp</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// Precedence -13xxxx❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T base case: an atomic binary relation ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">ToObject</span><span class="w"> </span><span class="p">#</span><span class="s"> object 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T base case: the inverse of an atomic binary relation ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">ToSubject</span><span class="w"> </span><span class="p">#</span><span class="s"> subject 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the transitive closure of a relation ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Transitive</span><span class="w"> </span><span class="p">#</span><span class="s"> *+ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the symmetric closure of a relation ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Symmetric</span><span class="w"> </span><span class="p">#</span><span class="s"> symmetric 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"> </span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the union of a list of relations ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Choice</span><span class="w"> </span><span class="p">#</span><span class="s"> choice 1,… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the composition of a list of relations ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Sequence</span><span class="w"> </span><span class="p">#</span><span class="s"> sequence 1,… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the reflexive relation ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Reflexive</span><span class="w"> </span><span class="p">#</span><span class="s"> reflexive 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">/T the reflexive relation restricted to a set of paths ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">HasType</span><span class="w"> </span><span class="p">#</span><span class="s"> hastype 1,… *--* 2,… </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130000</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTBinaries</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// Precedence -12xxxx❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">DependsOn</span><span class="w"> </span><span class="p">#</span><span class="s"> dependson </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">HasMeta</span><span class="w"> </span><span class="p">#</span><span class="s"> hasmeta </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Includes</span><span class="w"> </span><span class="p">#</span><span class="s"> includes </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">HasDomain</span><span class="w"> </span><span class="p">#</span><span class="s"> hasdomain </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">HasCodomain</span><span class="w"> </span><span class="p">#</span><span class="s"> hascodomain </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsInstanceOf</span><span class="w"> </span><span class="p">#</span><span class="s"> isinstanceof </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">RefersTo</span><span class="w"> </span><span class="p">#</span><span class="s"> refers </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Declares</span><span class="w"> </span><span class="p">#</span><span class="s"> declares </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsAliasFor</span><span class="w"> </span><span class="p">#</span><span class="s"> isaliasfor </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsAlignedWith</span><span class="w"> </span><span class="p">#</span><span class="s"> isalignedwith </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTUnaries</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// Precedence -12xxxx❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">IsDocument</span><span class="w"> </span><span class="p">#</span><span class="s"> document </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsTheory</span><span class="w"> </span><span class="p">#</span><span class="s"> theory </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsView</span><span class="w"> </span><span class="p">#</span><span class="s"> view </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsStructure</span><span class="w"> </span><span class="p">#</span><span class="s"> structure </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsConstant</span><span class="w"> </span><span class="p">#</span><span class="s"> constant </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsPattern</span><span class="w"> </span><span class="p">#</span><span class="s"> pattern </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsInstance</span><span class="w"> </span><span class="p">#</span><span class="s"> instance </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsDerivedDeclaration</span><span class="w"> </span><span class="p">#</span><span class="s"> deriveddeclaration </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsConAss</span><span class="w"> </span><span class="p">#</span><span class="s"> conass </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsStrAss</span><span class="w"> </span><span class="p">#</span><span class="s"> strass </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">IsNotation</span><span class="w"> </span><span class="p">#</span><span class="s"> notation </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120000</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMTLiterals</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// TODO: Literals ❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QMT</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// include the MMT base in notations</span>
<span class="cm">	include ?mmt ❙</span><span class="w"></span>

<span class="w">	</span><span class="cm">// TODO: Precedence ❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTQuery </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTProp </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTRelationExp </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTJudgements </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTUnaries </span><span class="p">❙</span><span class="w"> </span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTBinaries </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?QMTTypes </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://quotation.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="cm">/T   introduces a primitive type that exposes the type MMT terms of the underlying implementation</span>
<span class="cm">This can be seen as a first step towards MMT meta-programming but is used here only to represent quotations.</span>
<span class="cm">❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">TermLiterals</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermsTypesKinds</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the type of MMT terms ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">termliteral</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T makes all MMT terms (inlcudings ill-typed or ill-scoped ones) literals of type $termliteral$❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?TermLiteralRule</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">/T   the language features of quotation</span>
<span class="cm">This allows quoting terms that are well-typed in the current context.</span>

<span class="cm">The concrete syntax uses MMT&#39;s string interpolation feature with the identifier q, i.e., q&quot;t&quot; is the quotation of the term t.</span>
<span class="cm">Quoted terms are unevaluated, i.e., q&quot;1+1&quot; != q&quot;2&quot;. </span>

<span class="cm">Within t, it is allowed to escape back into evaluated terms: q&quot;1+${s}&quot; is the quasiquotation q&quot;1+e&quot; where e is the result of evaluating s.</span>
<span class="cm">❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Quotation</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">❙</span><span class="w"> </span><span class="cm">// LF is not actually needed here. But due a current bug, the comments are not type-checked correctly without LF. ❙</span><span class="w"></span>

<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?TermLiterals</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T For any [a:type], $Q a$ is the type of quotations of terms of type $a$.❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Quote</span><span class="w"> </span><span class="p">#</span><span class="s"> Q 1</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the quotation operator</span>
<span class="cm">     Because of interpolation, this is not a unary operator - instead, the evaluated subterms are replaced with free variables and bundled up in a substitution.</span>
<span class="cm">     For example, q&quot;1+${s}+2&quot; is internally represented as quote(l, x/s) where l is the term literal 1+x+2.❙</span><span class="w"></span>
<span class="w">  </span><span class="no">quote</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T the evaluation operator: For [a:type, q: Q a], $eval q$ is the evaluation of $q$ of type $a$.❙</span><span class="w"></span>
<span class="w">  </span><span class="no">eval</span><span class="w"> </span><span class="p">#</span><span class="s"> eval 1</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the concrete syntax for quotations (using string interpolation)❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Lexer</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T the formation rule: For [a:type], $Q a$ is a type.❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteFormation</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the introduction rule: In the simplest case, for [a:type, t:a], the quotation of $t$ has type $Q a$.❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteIntroduction</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the elimination rule: For [a:type, q: Q a], $eval q$ has type $a$.❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteElimination</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the type checking rule: For [a:type], we check [q: Q a] by checking that $eval q$ has type $a$.❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?QuoteTyping</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the beta-style reduction rule: For [a:type,t:a] the evaluation of the quotation $t$ reduces to $t$.❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EvalQuote</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T an auxiliary rule for normalizing quotations:</span>
<span class="cm">     For example, it reduces q&quot;1+${q&quot;2&quot;}&quot; to q&quot;1+2&quot;.❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ReduceQuote</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">/T   LF with quotation❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Quotation</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?LF</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">/T   a simple test theory ❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">QuotingInterpolationExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">a</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">c</span><span class="p">:</span><span class="w"> </span><span class="s">a</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">f</span><span class="p">:</span><span class="w"> </span><span class="s">a ⟶ a ⟶ a</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">t</span><span class="p">:</span><span class="w"> </span><span class="s">Q a ⟶ Q a</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[q] q</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">q1</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c c&quot;</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">q2</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${q1}&quot;</span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">q3</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${t q1}&quot;</span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">q4</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${t q&quot;f c c&quot;}&quot;</span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">q5</span><span class="p">:</span><span class="w"> </span><span class="s">Q a</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">q&quot;f c ${t q&quot;f c ${t q1}&quot;}&quot;</span><span class="p">❙</span><span class="w"> </span>
<span class="p">❚</span><span class="w"></span>

<span class="kn">namespace</span><span class="w"> </span><span class="s">examples/Quotation</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ExcludedMiddle</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">/urtheories?LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">bool</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ type</span><span class="p">❘#</span><span class="s"> ⊦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">disj</span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ bool ⟶ bool</span><span class="p">❘#</span><span class="s"> 1 ∨ 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">not</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ bool</span><span class="p">❘#</span><span class="s"> ¬ 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">em</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{f} ⊦ (eval f) ∨ ¬ (eval f)</span><span class="p">❙</span><span class="w"> </span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">PeanoInduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">/urtheories?LFQ</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?ExcludedMiddle</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">nat</span><span class="p">:</span><span class="w">  </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">zero</span><span class="p">:</span><span class="w"> </span><span class="s">nat</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">succ</span><span class="p">:</span><span class="w"> </span><span class="s">nat ⟶ nat</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">induction</span><span class="p">:</span><span class="w"> </span><span class="s">{f} ⊦ (eval f) zero ⟶ ({n} ⊦ (eval f) n ⟶ ⊦ (eval f) (succ n)) ⟶ ({n} ⊦(eval f) n)</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Scala</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">hasType</span><span class="w"> </span><span class="p">#</span><span class="s"> : 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Any</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Unit</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">unit</span><span class="w">     </span><span class="p">#</span><span class="s"> ()</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Product</span><span class="w">  </span><span class="p">#</span><span class="s"> Product [ 1,… ] </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Tuple</span><span class="w">    </span><span class="p">#</span><span class="s"> Tuple [ 1,… ]</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Function</span><span class="w"> </span><span class="p">#</span><span class="s"> Fun [ 1,… ] 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Lambda</span><span class="w">   </span><span class="p">#</span><span class="s"> ( V1T,… ) -2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1000010</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">List</span><span class="w">     </span><span class="p">#</span><span class="s"> List [ 1 ] </span><span class="k">prec</span><span class="w"> </span><span class="mi">100</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">list</span><span class="w">     </span><span class="p">#</span><span class="s"> List ( 1,… )</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">BigInt</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Double</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Boolean</span><span class="p">❙</span><span class="w">            </span>
<span class="w">  </span><span class="no">String</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ScalaOM</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Scala</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Term</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Context</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://semiformal.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Informal</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">informal</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InformalLiterals</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?InformalTyping</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Semiformal</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Informal</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">semiformal</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SemiformalInterpolation</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SemiformalTerm</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SemiformalInterpolationExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Semiformal</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">nat</span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">plus</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat ⟶ nat ⟶ nat</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 + 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">test</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat ⟶ nat ⟶ nat </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] sf&quot;the sum of all number from 1 to ${x+y}&quot;:nat</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">test2</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] sf&quot;the product of ${x+y:nat} and ${y+x:nat}&quot;:nat</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">  </span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://sequences.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Sequences</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Typed</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Nat</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">rep</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ^ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-20</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NTypeTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UniverseNType</span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">ellipsis</span><span class="w">  </span><span class="p">#</span><span class="s"> ⟨&#39; 2 | V1T &#39;⟩ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10002</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">index</span><span class="w">     </span><span class="p">#</span><span class="s"> 1 .. 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">9998</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">flatseq</span><span class="w">   </span><span class="p">#</span><span class="s"> ⟨ 1,… ⟩ </span><span class="k">prec</span><span class="w"> </span><span class="mi">0</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">foldLeft</span><span class="w"> </span><span class="p">#</span><span class="s"> foldL 1 2 3 4 </span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisInfer</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisTypeCheck</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisEqualityCheck</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?EllipsisInjective</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RepTypeCheck</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RepEqualityCheck</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?ExpandRep</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IndexInfer</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IndexCompute</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlatseqInjective</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?SolveArity</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LengthAwareApplyTerm</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LengthAwareBeta</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FoldLeftType </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFS</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?DHOL</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Sequences</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlexaryPi</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlexaryLambda</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?FlexaryApply</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Strings</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">string</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">empty</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">concat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">string ⟶ string ⟶ string</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 + 2</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/lf?Realize string rules/api/uom?StandardString</span><span class="p">❙</span><span class="w">  </span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/lf?Realize empty rules/api/uom?StringOperations/Empty</span><span class="p">❙</span><span class="w">  </span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/lf?Realize concat rules/api/uom?StringOperations/Concat</span><span class="p">❙</span><span class="w">  </span>

<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/literals?StandardStringInterpolation string concat</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">StringInterpolationExample</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?Strings</span><span class="w"> </span><span class="p">=</span><span class="w"></span>

<span class="w">  </span><span class="no">c</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">f</span><span class="p">:</span><span class="w"> </span><span class="s">string ⟶ string ⟶ string</span><span class="p">❘=</span><span class="w"> </span><span class="s">[x,y] x + y</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">q1</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA&quot;</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">q2</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${q1}&quot;</span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">q3</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${s&quot;a&quot; + s&quot;b&quot;}&quot;</span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">q4</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${f c s&quot;BB&quot;}&quot;</span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">q5</span><span class="p">:</span><span class="w"> </span><span class="s">string</span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">s&quot;AA ${f c s&quot;BB ${f q1 q1}&quot;}&quot;</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://substructural.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="cm">// This theory is under development.</span>
<span class="cm">Its goal is to investigate to what extent substructural languages can be represented in MMT.</span>
<span class="cm">This was motivated by a promising initial case study on representing ordered linear logic (done with Jeff Polakow, at LFMTP 2017).❚</span><span class="w"></span>

<span class="cm">//   theory Substructural =</span>
<span class="cm">   Sarrow  # 2 - 1 -&gt; 3  prec  -9990❙</span>
<span class="cm">   Slambda # [ 1 V2T,… ] 2 prec -10000❙</span>
<span class="cm">   Sapply  # 1%w…        prec -10❙</span>

<span class="cm">   class # class 1 2  prec 1000❙</span>

<span class="cm">   unordered ❙</span>
<span class="cm">   leftordered ❙</span>
<span class="cm">   rightordered ❙</span>
<span class="cm">   </span>
<span class="cm">   plain❙</span>
<span class="cm">   useall❙</span>
<span class="cm">   useonce❙</span>
<span class="cm">   linear❙</span>

<span class="cm">   rule rules?SArrowTerm❙</span>
<span class="cm">   rule rules?SLambdaTerm❙</span>
<span class="cm">   rule rules?SApplyTerm❙</span>
<span class="cm">   rule rules?SArrowTyping❙</span>
<span class="cm">   rule rules?SArrowEquality❙</span>
<span class="cm">   rule rules?SArrowBeta❙</span>
<span class="cm">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories</span><span class="p">❚</span><span class="w"></span>

<span class="cm">//   LF as meta-theory means using LF HOAS❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Subtyping</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="no">subtype</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type, B: type} type                  </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ⊆‍ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-9980</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">refl</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{A} A ⊆‍ A</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">trans</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B,C} A ⊆‍ B ⟶ B ⊆‍ C ⟶ A ⊆‍ C</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">covariant</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type, B1: A ⟶ type, B2: A ⟶ type} ({x:A} B1 x ⊆‍ B2 x) ⟶ ({x:A} B1 x) ⊆‍ ({x:A} B2 x)</span><span class="p">❙</span><span class="w"> </span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Inhabitation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">// &quot;! A&quot; is a judgments for the inhabitation (= non-emptiness) of &quot;A&quot;.</span>
<span class="cm">     If &quot;A&quot; is empty, so is &quot;!A&quot;. If &quot;A&quot; is non-empty, &quot;!A&quot; is a singleton.</span>
<span class="cm">     These types are useful when using proofs as judgments as guards, i.e., in situations where only the inhabitation of a type matters, not the choice of inhabitant.</span>
<span class="cm">     Also note, that if &quot;A&quot; is a type of proofs, then &quot;! A&quot; is essentially the same type but with proof irrelevance.   </span>
<span class="cm">  ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Inh</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">type ⟶ type                     </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ! 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="p">❘</span><span class="k">role</span><span class="w"> </span><span class="s">Judgment</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// introduction: If we have an inhabitant of &quot;A&quot;, then &quot;A&quot; is inhabited.</span>

<span class="cm">     This is similar to modal logic&#39;s necessitation rule, but we apply it even if there are unboxed assumptions in the context.</span>
<span class="cm">  ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">inh</span><span class="w">    </span><span class="p">:</span><span class="w"> </span><span class="s">{A} A ⟶ !A </span><span class="p">❘#</span><span class="s"> inh 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// The inverse operator does not exist exactly but almost: If we have &quot;!A&quot;, we can assume an &quot;x:A&quot; as long as we only use &quot;x&quot; to prove other &quot;!B&quot;-judgments.</span>
<span class="cm">  </span>
<span class="cm">  More generally, the declarations in this theory only return !-types.</span>
<span class="cm">  Thus, adding this theory does not affect the adequacy of an existing encoding.❙</span><span class="w"></span>
<span class="w">  </span><span class="no">elim</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">{A, B} !A ⟶ (A ⟶ !B) ⟶ !B</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// The operator &quot;inh&quot; is functorial. ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// Note that this is also the modal axiom K ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">K</span><span class="w">      </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} !(A ⟶ B) ⟶ !A ⟶ !B</span><span class="p">❘</span><span class="w"></span>
<span class="w">         </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B] [p,q] elim p [r: A ⟶ B] elim q [s: A] inh (r s)</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Thus, we have: &quot;A ⟶ B&quot; is stronger than &quot;!(A ⟶ B)&quot; is stronger than &quot;!A ⟶ !B&quot; (which is equivalent to &quot;A ⟶ !B&quot;).</span>
<span class="cm">     Set-theoretically, all 3 are equivalent, but proving the inverse directions requires non-canonically choosing an element, which we cannot do in type theory. ❙</span><span class="w"></span>
<span class="w">         </span>
<span class="w">  </span><span class="cm">// We can prove that multiple inhabitation operators are redundant.❙</span><span class="w"></span>
<span class="w">  </span><span class="no">idempotent</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} !!A ⟶ !A </span><span class="p">❘</span><span class="w"></span>
<span class="w">         </span><span class="p">=</span><span class="w"> </span><span class="s">[A][p] elim p [a]a</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// operationalizes the rule {A, P:!A, Q:!A} P = Q❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules/inhabitation?ProofIrrelevance</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">// an experimental theory for predicate subtypes❚</span><span class="w"></span>
<span class="cm">//   theory PredicateSubtypes : ?PLF =</span>
<span class="cm">  include ?Subtyping❙</span>
<span class="cm">  include ?Inhabitation❙</span>
<span class="cm">  </span>
<span class="cm">  Sub    : {A: type} (A ⟶ type) ⟶ type              ❘ # 1 | 2 prec 20❙</span>
<span class="cm">  sub    : {A, P} {x: A} !(P x) ⟶ A|P               ❘ # 3 by 4❙</span>

<span class="cm">  subA_A    : {A,P} A|P ⊆‍ A❙</span>
<span class="cm">  subA_subA : {A,P,Q} ({x} P x ⟶ Q x) ⟶ A|P ⊆‍ A|Q❙</span>

<span class="cm">  // elim   : {A,P}{x: A|P} ! (P x)❙</span>
<span class="cm">  // sub x (elim x) = x❙</span>
<span class="cm">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories/reflection</span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Terms</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">/urtheories?Typed</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">formation</span><span class="w"> </span><span class="p">#</span><span class="s"> {| 1 |} 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">reflect</span><span class="w">   </span><span class="p">#</span><span class="s"> ⌜ 1 : 2 ⌝ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">eval</span><span class="w">      </span><span class="p">#</span><span class="s"> ⌞ 1 ⌟ 2   </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">elim</span><span class="w">      </span><span class="p">#</span><span class="s"> 1 ^ 2     </span><span class="k">prec</span><span class="w"> </span><span class="mi">-10000</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LFReflection</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">/urtheories?LF</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Terms</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lf</span><span class="w"> </span><span class="s">scala://lf.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">lfx</span><span class="w"> </span><span class="s">scala://LFX.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>


<span class="kd">theory</span><span class="w"> </span><span class="nv">Metadata</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">constructorargument</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">/T We define a formal language for basic mathematical objects in LF. ❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Subtyping</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Subtyping?LFSubtyped </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">/T First, some logic. ❚</span><span class="w"></span>

<span class="w">                                               </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Logic</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/TypedHierarchy?LFHierarchy</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Records?LFRecords </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?Ded </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Subtyping?LFWithVariance </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">// rule rules?ApplyRule ❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T the type of booleans, i.e., all formulas are represented as terms of LF-type $prop$ ❙</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// bool : type ❘ // = BOOL ❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">prop</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❘</span><span class="w"> </span><span class="p">@</span><span class="no"> bool </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">BOOL </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T one LF-type for each formula holding its proofs                 </span>
<span class="cm">	 For example, the LF type ⊦ 0 ≐ 1 is empty because that formula has no proofs.</span>
<span class="cm">	 Axioms are declared as constants of the corresponding type, e.g., a constant of type $⊦ true$ for the axiom of truth.❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">ded</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">prop ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ⊦ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-500</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Judgment </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">DED </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">ImplicitProof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} ⊦ A </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ImplicitProof 1 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">lf?TermIrrelevanceRule (ded) ([A : prop] ImplicitProof A) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T Equality on terms. The type A is left implicit and can be inferred by MMT ❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">eq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:𝒰 100} A ⟶ A ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 ≐ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = EQUAL </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">// coercion : {A : type, P : A ⟶ prop,a} ⊦ P a ⟶ ⟨ A | ([x] ⊦ P x) ⟩ ❘ # coerce 3 %I4❙</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// coercion_theorem : {A : type,P : A ⟶ prop,a,p : ⊦ P a} ⊦ eq ⟨ A | ([x] ⊦ P x) ⟩ (coercion A P a p) a ❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?BooleanLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">// false_is_FALSE : ded (FALSE ≐ false) ❙</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// true_is_TRUE : ded (TRUE ≐ true) ❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">not</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ¬ 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">neq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: 𝒰 100} A ⟶ A ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 ≠ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,a,b] ¬ (a ≐ b) </span><span class="p">❙</span><span class="w"></span>

<span class="w">	 </span><span class="no">and</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ bool ⟶ bool</span><span class="p">❘#</span><span class="s"> 1 ∧ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-110</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">or</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ bool ⟶ bool </span><span class="p">❘#</span><span class="s"> 1 ∨ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-120</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = [A,B] ¬ (¬A ∧ ¬ B) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">implies</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ bool ⟶ bool </span><span class="p">❘#</span><span class="s"> 1 ⇒ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-130</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = [A,B] B ∨ ¬A </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">iff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">bool ⟶ bool ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ⇔ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-140</span><span class="w"> </span><span class="p">❘</span><span class="cm">// = [A,B] (A ⇒ B) ∧ (B ⇒ A) </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	 </span><span class="no">forall</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100} (A ⟶ bool) ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∀ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100</span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">exists</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100} (A ⟶ bool) ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∃ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-100</span><span class="w"> </span><span class="p">❘</span><span class="cm">// = [A,f] ¬ ∀ [x:A] ¬ f x </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">unique</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100} (A ⟶ bool) ⟶ A ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P,x] ∀ [y:A] P y ⇒ y ≐ x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> unique 2 3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">exists_unique</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100} (A ⟶ bool) ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∃! 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-101</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P] ∃ [x] (P x ∧ unique P x) </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	 </span><span class="cm">/T Equality on types (semantics missing) ❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">tpeq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type ⟶ type ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ≐≐ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-6</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Eq </span><span class="p">❙</span><span class="w">	 		</span>
<span class="w">	 </span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	 </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">NaturalDeduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">tru_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">⊦ true </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">fals_elimination</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} ⊦ false ⟶ ⊦ A </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">fals_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} ⊦ A ⟶ ⊦ ¬ A ⟶ ⊦ false </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">forall_elim</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100, P : A ⟶ bool}⊦ ∀ P ⟶ {x : A}⊦ P x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> forallE 3 4</span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">forall_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100, P : A ⟶ bool, p : {x : A}⊦P x}⊦ ∀[x] P x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> forallI 3 </span><span class="p">❙</span><span class="w"></span>

<span class="w">	 </span><span class="no">and_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} ⊦ A ⟶ ⊦ B ⟶ ⊦ (A ∧ B) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">and_elim_left</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} ⊦ (A ∧ B) ⟶ ⊦ A </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">and_elim_right</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} ⊦ (A ∧ B) ⟶ ⊦ B </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="no">not_introduction</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} (⊦ A ⟶ ⊦ false) ⟶ ⊦ ¬ A </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">not_elim</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} ⊦ ¬ ¬ A ⟶ ⊦ A </span><span class="p">❙</span><span class="w"></span>

<span class="w">	 </span><span class="no">tnd</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} ⊦ A ∨ ¬A </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = [A: bool] not_introduction ([p : ⊦ (¬A ∧ ¬¬A)] fals_introduction (not_elim (and_elim_right p)) (and_elim_left p)) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="w">	 </span><span class="cm">/T basic axioms governing Equality. Again, all the type parameters can be left implicit ❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">eq_refl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t:𝒰 100,A: t} ⊦ A ≐ A </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> eq_refl 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">eq_cong</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t : 𝒰 100, s : 𝒰 100, f : t ⟶ s, A : t, B: t}</span>
<span class="s">	 		⊦ A ≐ B ⟶ ⊦ (f A) ≐ (f B) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> eq_cong 3 6</span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	 </span>

<span class="cm">/T Now some theories that introduce primitive types and literals for them.</span>
<span class="cm">     Because literals must modify the parser, they are supplied as rules that are implemented in a plugin.❚</span><span class="w">   </span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">NatLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Subtyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?NatLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://cds.omdoc.org/urtheories?NatRels </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ℕ </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">NAT </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatLiterals ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">pos_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">⟨ n : nat_lit | ⊦ n ≠ 0 ⟩ </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ℕ+ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PosLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">pos_are_nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit &lt;* nat_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">succ_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit ⟶ pos_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NatSucc </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// not needed anymore: rule rules?NatSuccInverse ❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">plus_pos_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit ⟶ pos_lit ⟶ pos_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PosPlus </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">plus_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit ⟶ nat_lit ⟶ nat_lit </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">plus </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatPlus ❙</span><span class="w"></span>
<span class="w">   	</span><span class="no">times_pos_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit ⟶ pos_lit ⟶ pos_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?PosTimes </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">times_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit ⟶ nat_lit ⟶ nat_lit </span><span class="p">❘=</span><span class="w"> </span><span class="s">times </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatTimes ❙</span><span class="w"></span>
<span class="w">    </span><span class="no">leq_nat_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit ⟶ nat_lit ⟶ bool </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">LEQ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="cm">// rule rules?NatLeq ❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">IntLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">int_lit</span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ℤ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntegerLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">minus_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit ⟶ int_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntMinus </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">plus_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit ⟶ int_lit ⟶ int_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntPlus </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">times_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit ⟶ int_lit ⟶ int_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntTimes </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">leq_int_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit ⟶ int_lit ⟶ bool </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?IntLeq </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	</span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">RealLiterals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">	</span><span class="no">real_lit</span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ℝ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">leq_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit ⟶ bool </span><span class="p">❙</span><span class="w"></span>
<span class="w">   	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealLeq </span><span class="p">❙</span><span class="w"></span>
<span class="w">   	</span><span class="no">minus_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit  </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> - 1 </span><span class="k">prec</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealMinus </span><span class="p">❙</span><span class="w">   </span>
<span class="w">   	</span><span class="no">plus_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit ⟶ real_lit </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 + 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">25</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealPlus </span><span class="p">❙</span><span class="w"></span>
<span class="w">   	</span><span class="no">times_real_lit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit ⟶ real_lit </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 × 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealTimes </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span>
<span class="w">	</span><span class="cm">// square_is_pos : {r : ℝ} ⊦ leq_real_lit 0 (times_real_lit r r) ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">sqrt</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">ℝ ⟶ ℝ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?RealSqrt </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">     </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Literals</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?RealLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?NatLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?IntLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Subtyping </span><span class="p">❙</span><span class="w"></span>

<span class="w">   </span><span class="no">ints_are_real</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">int_lit &lt;* real_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">nats_are_int</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit &lt;* int_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">nats_are_real</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">nat_lit &lt;* real_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">pos_are_int</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit &lt;* int_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">pos_are_real</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">pos_lit &lt;* real_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="cm">// rule rules?NumberLiterals ❙</span><span class="w"></span>

<span class="w">   </span><span class="cm">// test : ⊦ leq_lit 0 1 ❘ = tru_introduction ❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// test2 : ⊦ nat_lit_succ 1 ≐ 2 ❘ = eq_refl 2 ❙</span><span class="w"></span>
<span class="w">	 </span>
<span class="p">❚</span><span class="w"></span>
<span class="w">   </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Trigonometry</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?RealLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">tan</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit    </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">sin</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit    </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">cos</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit    </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">atan</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit    </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">asin</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit    </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">acos</span><span class="w">   </span><span class="p">:</span><span class="w"> </span><span class="s">real_lit ⟶ real_lit    </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Tan </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Sin </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Cos </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Atan </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Asin </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?Acos </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
<span class="w">	 </span>
<span class="cm">/T String literals are also needed occasionally, e.g., in the LMFDB.❚</span><span class="w"></span>
<span class="w"> </span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">Strings</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic</span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">string</span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?StringLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	 </span><span class="no">concat</span><span class="p">:</span><span class="w"> </span><span class="s">string ⟶ string ⟶ string</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">/T Now some more complex types. First lists.❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Lists</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">   </span><span class="kn">include</span><span class="w"> </span><span class="s">http://gl.mathhub.info/MMT/LFX/Datatypes?LFLists </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">InformalProofs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Strings </span><span class="p">❙</span><span class="w"></span>
<span class="w">   	 </span>
<span class="w">	</span><span class="no">proofsketch</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : prop} string ⟶ ⊦ A </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> sketch 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">byproof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} ⊦ A ⟶ ⊦ B </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> by 3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">addproofstep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B,C: prop} ⊦ A ⟶ ⊦ B ⟶ ⊦ B </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 4 and 5 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">trivial</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : prop} ⊦ A </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A] sketch &quot;trivial&quot; </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> trivial %I1 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>


<span class="cm">/T (Finite) sets ❙</span>
<span class="cm">theory Sets : ur:?LF =</span>
<span class="cm">   include ?Logic❙</span>
<span class="cm">   /T the type operator of sets along with its constructors❙</span>
<span class="cm">   set: type ⟶ type ❙</span>
<span class="cm">   </span>
<span class="cm">   empty: {A} (list A) ❘# ∅ 1❘## ∅ %I1 ❙</span>
<span class="cm">   cons: {A} A ⟶ (list A) ⟶ (list A)❘ # 2 , 3 ❙ </span>
<span class="cm">❚</span><span class="w"></span>

<span class="cm">/T Multisets ❙</span>

<span class="cm">/T &quot;Finite hybrid sets&quot; (mutlisets with possibly negative mutliplicities) ❙</span>

<span class="cm">/T Now vectors, i.e., fixed-length lists.❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Vectors</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Literals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">   </span><span class="cm">/T the type operator of vectors (fixed-length lists) over a given type ❙</span><span class="w"></span>
<span class="w">   </span><span class="no">vector</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">𝒰 100 ⟶ nat_lit ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ^^ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span>
<span class="w">   </span><span class="no">zerovec</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t : 𝒰 100} vector t 0 </span><span class="p">❙</span><span class="w"></span>
<span class="w">   </span><span class="no">vector_prepend</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t: 𝒰 100,n : nat_lit, a : t, b : vector t n} t ^^ (succ_nat_lit n) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 ; 4</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Matrices</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Vectors </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">  </span><span class="cm">/T the type operator of matrices over a given type❙</span><span class="w"></span>
<span class="w">  </span><span class="no">matrix</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">𝒰 100 ⟶ nat_lit ⟶ nat_lit ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[T,n,m] vector (vector T m) n </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">OptionType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">Option</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">𝒰 100 ⟶ 𝒰 100 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">isDefined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} Option A ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> isDefined 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">OptionGet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, a : Option A} ⊦ isDefined a ⟶ A </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">None</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100} Option A </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> None </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">None_is_not_Defined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100} ⊦ isDefined (None A) ≐ false </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">Not_None_is_Defined</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A, a : Option A} ⊦ (a ≠ None A) ⟶ ⊦ isDefined a </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">DescriptionOperator</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?OptionType </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">that</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A:𝒰 100,P:A ⟶ bool} ⊦ (∃! P) ⟶  A </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ι 2 %I3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">that_proof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100, P : A ⟶ bool, p : ⊦ ∃! P} ⊦ P (that A P p) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">if_then_else_exists_proof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,P,a:A,b:A} ⊦ ∃! [x:A] (P ∧ x ≐ a) ∨ (¬ P ∧ x ≐ b) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> iteep 2 3 4</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">if_then_else</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100, P : bool, a : A, b : A}A </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> if 2 then 3 else 4 </span><span class="p">❘</span><span class="w"></span>
<span class="w">		</span><span class="p">=</span><span class="w"> </span><span class="s">[A,P,a,b] that A ([x] (P ∧ x ≐ a) ∨ (¬ P ∧ x ≐ b)) (iteep P a b) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">if_then_else_case</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100, P : bool, a : A, b : A}A </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P,a,b] if P then a else b </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> case 2 ⟹ 3 . 4 </span><span class="k">prec</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">if_true</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100, P : bool, a : A, b : A, p : ⊦ P} ⊦ (if P then a else b) ≐ a </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = [A,P,a,b,p] _ </span><span class="p">❘</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">if_false</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : 𝒰 100, P : bool, a : A, b : A, p : ⊦ ¬ P } ⊦ (if P then a else b) ≐ b </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = [A,P,a,b,p] _ </span><span class="p">❘</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ProductTypes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/Sigma?LFSigma</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="cm">// to have it in the meta-theory ❙</span><span class="w">                       </span>
<span class="p">❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">FiniteTypes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/Finite?LFFinite</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kd">theory</span><span class="w"> </span><span class="nv">InductiveTypes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">http://gl.mathhub.info/MMT/LFX/WTypes?Inductive</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Sequences</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?Sequences </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">ur:?LFS </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">forall_seq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type}{n} (A^n ⟶ prop) ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∀n 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-101</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">exists_seq</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A: type}{n} (A^n ⟶ prop) ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∃n 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-101</span><span class="w"> </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,n][P] ¬ forall_seq A n [s : A^n] ¬ (P s)</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">/T Finally, a theory that puts everything together (not recommended, because modularity) ❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Math</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?PLF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Subtyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Logic </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?NaturalDeduction </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Literals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Trigonometry </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Strings </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?InformalProofs </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Lists </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Vectors </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Matrices </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?OptionType </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?ProductTypes </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sequences </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Classes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="no">class</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">cls_element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">class ⟶ class ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ∈ 2 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t} ⊦ (∀[e] e ∈ s ⇔ e ∈ t) ⇒ s ≐ t </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_extensionality 1 2 </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?InformalProofs </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">set</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">⟨ s : class | ⊦ ∃ [C : class] s ∈ C ⟩ </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> set </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">emptyclass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∅ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_emptyClassIsEmpty</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} ⊦ ¬ s ∈ ∅ </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_emptyClassIsEmpty 1 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">implicit view</span><span class="w"> </span><span class="nv">ZFinNBG</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?ZFBase</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nv">?Classes</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd?InformalProofs </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">set</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">set </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">element</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] cls_element s t </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">emptyset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">emptyclass </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_emptySetIsEmpty</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s: set] axiom_emptyClassIsEmpty s </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_extensionality</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] sketch &quot;from extensionality&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_separation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[P,s] sketch &quot;axiomatically&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_regularity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] sketch &quot;axiomatically&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_pairing</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] sketch &quot;axiomatically&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_union</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] sketch &quot;axiomatically&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_powerset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] sketch &quot;axiomatically&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_replacement</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[a,f] sketch &quot;axiomatically&quot; </span><span class="p">❙</span><span class="w"></span>

<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SetTypeConversions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">elem</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ type </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">asSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type ⟶ set </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">setAsElem</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a} ⊦ a ∈ A ⟶ elem A </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> asTerm 1 2 %I3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">elemAsSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type} A ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> asElem 2</span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">axiom_asElemIsElem</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a : A} ⊦ (asElem a) ∈ (asSet A) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_inverses1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} ⊦ asSet (elem s) ≐ s </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_inverses2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t} ⊦ elem (asSet t) ≐ t </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_asTermElem1</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a:A} ⊦ asTerm (asSet A) (asElem a) ≐ a </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">axiom_asTermElem2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,a,p:⊦a ∈ A} ⊦ asElem (asTerm A a) ≐ a </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="cm">// rule rules?SetCoercionRule ❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LiftSeparation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_sepIsPredSub</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,P : set ⟶ prop} ⊦ elem ⟪ s | P ⟫ ≐ ⟨ x : (elem s) | ⊦ P (asElem x) ⟩ </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_predSubIsSep</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{t,P : t ⟶ prop} ⊦ asSet ⟨ x : t | ⊦ P x ⟩ ≐ ⟪ asSet t | ([x] P (asTerm (asSet t) x)) ⟫ </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LiftProduct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?CartesianProduct </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?KuratowskiPairs </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?ProductTypes </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="cm">// axiom_productType : {s,t} ⊦ elem (product s t) ≐ (elem s) × (elem t) ❘ role Simplify ❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?LiftProductType </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_productSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t} ⊦ asSet (s × t) ≐ product (asSet s) (asSet t) </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_pairType</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t,S,T} ⊦ asTerm (product S T) (pair s t) ≐ ⟨ (asTerm S s) , (asTerm T t) ⟩ </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_pairSet</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{S,T,s : S,t : T} ⊦ asElem ⟨ s , t ⟩ ≐ pair (asElem s) (asElem t) </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="cm">// theory LiftRelations : fnd:?Logic =</span>
<span class="cm">    include ?Relations ❙</span>
<span class="cm">    include ?LiftProduct ❙</span>


<span class="cm">    axiom_relType : {a:set,b:set} ⊦ elem (℘ (product a b)) ≐ (elem a ⟶ elem b ⟶ prop) ❘ role Simplify ❙</span>
<span class="cm">    axiom_relSet : {A,B} ⊦ asSet (A ⟶ B ⟶ prop) ≐ ℘ (product (asSet A) (asSet B)) ❘ role Simplify ❙</span>
<span class="cm">    axiom_relType2 : {a:set,b:set,r: relation a b} ⊦ eq (elem a ⟶ elem b ⟶ prop) (asTerm (℘ (product a b)) r) ([x : elem a, y : elem b] (pair (asElem x) (asElem y)) ∈ r ) ❘ role Simplify ❙</span>
<span class="cm">    axiom_relSet2 : {A,B,R : A ⟶ B ⟶ prop} ⊦ asElem R ≐ ⟪ ℘ (product (asSet A) (asSet B)) | ([x] ∃[a] ∃[b] x ≐ pair a b ∧ R (asTerm (asSet A) a) (asTerm (asSet B) b) ) ⟫ ❘ role Simplify ❙</span>
<span class="cm">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">LiftOmega</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Infinity </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?NatLiterals </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">axiom_lift_omega</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">⊦ elem ω ≐ ℕ </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lift_Nat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">⊦ asSet ℕ ≐ ω </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lift_zero</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">⊦ asTerm ω ∅ ≐ 0 </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lower_zero</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">⊦ asElem 0 ≐ ∅ </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lift_succ</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{n} ⊦ asTerm ω (set_succ n) ≐ succ_nat_lit (asTerm ω n) </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">axiom_lower_succ</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{n} ⊦ asElem (succ_nat_lit n) ≐ set_succ (asElem n) </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">TypedSets</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	 </span><span class="cm">// include base:?Lists ❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?SetTypeConversions </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Powerset </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T the type operator of sets along with its constructors ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">setOf</span><span class="p">:</span><span class="w"> </span><span class="s">type ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A] ⟨ x : set | ⊦ x ∈ (℘ (asSet A)) ⟩ </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">fromPred</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A : type} (A ⟶ prop) ⟶ setOf A </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,P] ⟪ ℘ (asSet A) | ([x] P (asTerm (asSet A) x)) ⟫ </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> asSet 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">asPred</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} setOf A ⟶ A ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,s] [x] (asElem x) ∈ s </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> asPred 2 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// setCons: {A} A ⟶ set A ⟶ set A ❘ = [A] [a,P] [x] P x ∨ x ≐ a❘ # 3 &lt;- 2 ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// setList : {A} List A ⟶  set A ❘ # ≪ 2 ≫ ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// inSet : {A : type} A ⟶ set A ⟶ prop ❘ = [A][a,P] P a ❘ # 2 ∈ 3 ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// bsetst : {A} set A ⟶ (A ⟶ prop) ⟶ set A ❘ = [A][P,Q] [x] P x ∧ Q x ❘ # ⟪ 2 | 3 ⟫ ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// fullset : {A} set A ❘ = [A] [x] true ❘ # fullset 1 ❙</span><span class="w"></span>
<span class="w">   </span><span class="cm">// TODO, need a lot of congruence rules that make sure that setcons ACI ❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/sets</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Sets</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="no">set</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">element</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ∈ 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">emptyset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∅ </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">axiom_emptySetIsEmpty</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} ⊦ ¬ s ∈ ∅ </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">subset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] ∀ [z] z ∈ s ⇒ z ∈ t </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ⊑ 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">disjoint</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] ¬∃[e] e ∈ s ∧ e ∈ t </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">prop_extensionality</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t](∀[e] e ∈ s ⇔ e ∈ t) ⇒ s ≐ t </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_separation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">(set ⟶ prop) ⟶ set ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[P][s]∃![t]∀[e]e ∈ t ⇔ (e ∈ s ∧ P e) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_regularity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s]s ≠ ∅ ⇒ ∃ [e] e ∈ s ∧ (disjoint s e) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_pairing</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] ∃[z] x ∈ z ∧ y ∈ z </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_pairing_unique</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] ∃![z] x ∈ z ∧ y ∈ z ∧ ∀[w] w ∈ z ⇒ (w ≐ x ∨ w ≐ y) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_union</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x] ∃![y]∀[z] z ∈ y ⇔ ∃[w] z ∈w ∧ w ∈ x </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_powerset</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x]∃![y] ∀[z] z ∈ y ⇔ z ⊑ x </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_replacement</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A][f : set ⟶ set] ∃![B]∀[z] (z ∈ B ⇔ ∃[a] a ∈ A ∧ z ≐ f a) </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_extensionality</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s,t} ⊦ prop_extensionality s t </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Separation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_separation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{P,s} ⊦ prop_separation P s </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_separation 1 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">sep_constructor</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s : set,P : set ⟶ prop}set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,P] that set ([x] ∀[e]e ∈ x ⇔ (e ∈ s ∧ P e)) (axiom_separation P s)</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ⟪ 1 | 2 ⟫ </span><span class="k">prec</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Intersection</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">intersect</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,t] ⟪ s | ([x] x ∈ t) ⟫ </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ∩ 2 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Regularity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_regularity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{s} ⊦ prop_regularity s </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Pairing</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?InformalProofs </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">axiom_pairing</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x,y} ⊦ prop_pairing x y </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">lemma_pairing_unique</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x,y : set} ⊦ prop_pairing_unique x y </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_pairing_unique 1 2 </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] sketch &quot;provable&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">uopair</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] that set ([z] x ∈ z ∧ y ∈ z ∧ ∀[w] w ∈ z ⇒ (w ≐ x ∨ w ≐ y)) (lemma_pairing_unique x y) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">singleton</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] uopair s s </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">KuratowskiPairs</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Pairing </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">pair</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x,y] uopair (uopair x y) x </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Union</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_union</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x} ⊦ prop_union x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_union 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">union</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] that set ([x] ∀[z] z ∈ x ⇔ ∃[w] z ∈w ∧ w ∈ s) (axiom_union s) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ⋃ 1 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">BinaryUnion</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?KuratowskiPairs </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Union </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">binaryunion</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[a,b] ⋃ (uopair a b) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ∪ 2</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Powerset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_powerset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x} ⊦ prop_powerset x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_powerset 1</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">powerset</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[x] that set ([y] ∀[z] z ∈ y ⇔ z ⊑ x) (axiom_powerset x) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ℘ 1 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">CartesianProduct</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Powerset </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?BinaryUnion </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">product</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B] sep_constructor (℘ (℘ (A ∪ B))) ([p] ∃[a]∃[b] a ∈ A ∧ b ∈ B ∧ p ≐ pair a b) </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Relations</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?CartesianProduct </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?Subtyping </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">prop_relation</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s,A,B : set] s ⊑ (product A B) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_relation 1 2 3</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">relation</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ type </span><span class="p">❘=</span><span class="w"> </span><span class="s">[A,B] ⟨ s : set | ⊦ prop_relation s A B ⟩ </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Functions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Relations </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?InformalProofs </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">prop_function</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[f,A,B] prop_relation f A B ∧ ∀[x] x ∈ A ⇒ ∃[y] y ∈ B ∧ (pair x y) ∈ f </span><span class="p">❙</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// TODO ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">function</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ type </span><span class="p">❘=</span><span class="w"> </span><span class="s">[A,B] ⟨ s:set | ⊦ prop_function s A B ⟩ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">setfunapply</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B ⟶ {a : set}⊦ a ∈ A ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f,a,p] ι ([x] (pair a x) ∈ f) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 @ 4 %I5 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">theorem_setfun</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B,f : function A B, a} ⊦ (f @ a) ∈ B </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f,a] sketch &quot;by definition&quot; </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Replacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Sets </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">fnd:?DescriptionOperator </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">axiom_replacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,f} ⊦ prop_replacement a f </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> axiom_replacement 1 2</span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">replacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ (set ⟶ set) ⟶ set </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,f] that set ([B] ∀[z] (z ∈ B ⇔ ∃[a] a ∈ A ∧ z ≐ f a)) (axiom_replacement A f) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> Img 2 of 1 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Infinity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?BinaryUnion </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">set_succ</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[n] n ∪ (singleton n) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_infinity</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[N] ∅ ∈ N ∧ ∀[n] n ∈ N ⇒ (set_succ n) ∈ N </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">omega</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ω </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ι [x] prop_infinity x ∧ ∀[z] prop_infinity z ⇒ x ⊑ z</span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZFBase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Extensionality </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Separation </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Regularity </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Pairing </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Union </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Powerset </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Replacement </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Infinity </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">FunctionsExtended</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Functions </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">prop_injective</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f] ∀[x] ∀[y] x ∈ A ∧ y ∈ A ⇒ (f@x ≐ f@y ⇒ x ≐ y) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_injective 3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">prop_surjective</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f] ∀[y] y ∈ B ⇒ ∃[x] x ∈ A ∧ f@x ≐ y </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_surjective 3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">prop_bijective</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A,B} function A B ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,B,f] prop_injective f ∧ prop_surjective f </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> prop_bijective 3 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Finite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?FunctionsExtended </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Infinity </span><span class="p">❙</span><span class="w"></span>

<span class="w">    </span><span class="no">prop_finite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] ∃[n] n ∈ ω ∧ ∃[f : function s n] prop_injective f </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="no">prop_infinite</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[s] ¬ prop_finite s </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZF</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZFBase </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Finite </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Intersection </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">setdiff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘=</span><span class="w"> </span><span class="s">[A,B] ⟪ A | ([x] ¬ x ∈ B) ⟫ </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 \ 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">subtract</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘=</span><span class="w"> </span><span class="s">[A,a] A \ (singleton a) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 - 3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">symdiff</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">set ⟶ set ⟶ set </span><span class="p">❘=</span><span class="w"> </span><span class="s">[A,B] (A \ B) ∪ (B \ A) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 Δ 3 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Choice</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Functions </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">prop_choiceFunction</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[A,f : function A (⋃ A)] ∀[a] a ∈ A ⇒ (f @ a) ∈ a </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">choice</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{A} ⟨ f : function A (⋃A) | ⊦ prop_choiceFunction A f ⟩ </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZFCBase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZFBase </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?Choice </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">ZFC</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZFCBase </span><span class="p">❙</span><span class="w"></span>
<span class="w">    </span><span class="kn">include</span><span class="w"> </span><span class="s">?ZF </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/Units</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Dimensions</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>

<span class="w">  </span><span class="cm">/T An SI Dimension. ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">dimension</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation?IntLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T A normalized representation used for equality reasoning etc. ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">NormedDimension</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">ℤ ⟶ ℤ ⟶ ℤ ⟶ ℤ ⟶ ℤ ⟶ ℤ ⟶ ℤ ⟶ dimension </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T We want the actual dimensions as a dimension. ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T We use the SI base dimensions for this. ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Length</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 1 0 0 0 0 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Time</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 0 1 0 0 0 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Mass</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 1 0 0 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Amount</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 1 0 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Temperature</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 1 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Current</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 0 1 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">LuminousIntensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 0 0 1 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">DimNone</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedDimension 0 0 0 0 0 0 0 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Now we want to make even more dimensions. ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">DimTimes</span><span class="p">:</span><span class="w"> </span><span class="s">dimension ⟶ dimension ⟶ dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 *&#39; 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">DimDiv</span><span class="p">:</span><span class="w"> </span><span class="s">dimension ⟶ dimension ⟶ dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 /&#39; 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?DimEq </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">DimensionsExtended</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">ur:?LF</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Dimensions</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Dimensionless stuff❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Information</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">DimNone</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Velocity, Accelleration ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Velocity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Length /&#39; Time</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Acceleration</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Velocity /&#39; Time</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Area and Volume❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Area</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Length *&#39; Length</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Volume</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Area *&#39; Length</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Densities ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">VolumeDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">DimNone /&#39; Volume </span><span class="p">❘</span><span class="w">  </span><span class="cm">// # Density //?? </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">AreaDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">DimNone /&#39; Area</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">LineDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">DimNone /&#39; Length</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Force and Pressure❙</span><span class="w">                   </span>
<span class="w">  </span><span class="no">Force</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Mass *&#39; Acceleration</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Pressure</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Force /&#39; Area</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Electric Charge and Charge Densities❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricCharge</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Current *&#39; Time </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricChargeVolumeDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">ElectricCharge *&#39; VolumeDensity </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ElectricChargeDensity</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricChargeAreaDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">ElectricCharge *&#39; AreaDensity </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ElectricChargeSurfaceDensity</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricChargeLineDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">ElectricCharge *&#39; LineDensity</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Energy and Power❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Energy</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Force *&#39; Length </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Power</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Energy /&#39; Time</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Basic Electrostatic Units❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricPotential</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Energy /&#39; ElectricCharge </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> Voltage</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricDisplacement</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricCharge /&#39; Area </span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">ElectricCurrentDensity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘=</span><span class="w"> </span><span class="s">Current *&#39; AreaDensity </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> Polarization </span><span class="p">❘</span><span class="w"> </span><span class="cm">// # CurrentDensity </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricField</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Voltage /&#39; Length </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ElectricFieldIntensity </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// Other Electrical Units❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalResistance</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Voltage /&#39; Current </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalResistivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricalResistance *&#39; Area /&#39; Length </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalConductivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">DimNone /&#39; ElectricalResistivity </span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">ElectricFlux</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Voltage *&#39; Length </span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span><span class="no">ElectricalCapacitance</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricCharge /&#39; Voltage </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalPermittivity</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">ElectricalCapacitance /&#39; Length </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">ElectricalMobility</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Velocity /&#39; ElectricField </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">IonRecombination</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Volume /&#39; Time </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">// Magnetism // Hoping we don&#39;t need that for now</span>
<span class="cm">  </span>
<span class="cm">  // Heat-related , cf. Thermistor example❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Heat</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Energy </span><span class="p">❙</span><span class="w"> </span>
<span class="w">	</span><span class="cm">// ThermalConductivity : dimension ❘ = Energy /&#39; Length /&#39; Temperature ❙</span><span class="w"> </span><span class="cm">// TODO Name clash with quantities.mmt ❙</span><span class="w"></span>
<span class="w">	</span><span class="no">ThermalHeatFlux</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Energy /&#39; Area </span><span class="p">❙</span><span class="w"> </span>
<span class="w">  </span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/Units</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">fnd</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>
<span class="kn">import</span><span class="w"> </span><span class="nn">rules</span><span class="w"> </span><span class="s">scala://rules.mitm.mmt.kwarc.info</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="cm">//   http://mathhub.info/MMT/physics-units?QEBase ❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Units</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation?RealLiterals </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?Dimensions </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">unit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension ⟶ type </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">QE</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension ⟶ type </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">  	</span><span class="cm">/T Dimensionless Quantity Expressions are real numbers ❙</span><span class="w"></span>
<span class="w">  	</span><span class="no">NoneIsReal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">⊦ QE DimNone ≐≐ real_lit </span><span class="p">❙</span><span class="w"></span>
<span class="w">  	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?NoneIsReal </span><span class="p">❙</span><span class="w"></span>
<span class="w">  	</span>
<span class="w">	</span><span class="no">unitappl</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d : dimension} real_lit ⟶ unit d ⟶ QE d </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 of 3 </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"># 2 3</span><span class="p">❙</span><span class="w"> </span><span class="cm">// test... ❙</span><span class="w"></span>
<span class="w">  	  </span>
<span class="w">  	</span><span class="no">scalar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X} QE X ⟶ real_lit </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> scalar 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  	</span><span class="no">scalar_commutes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X : dimension,r, u : unit X} ⊦ scalar (r of u) ≐ r </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">  	</span><span class="no">unitof</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X} QE X ⟶ unit X </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> unitof 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  	</span><span class="no">unitof_commutes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{X : dimension,r, u : unit X} ⊦ unitof (r of u) ≐ u </span><span class="p">❘</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="s">Simplify </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span>
<span class="w">	</span><span class="no">lift</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{din : dimension, dout : dimension, f : ℝ ⟶ ℝ, u : unit din ⟶ unit dout}QE din ⟶ QE dout </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> unit_lift 3 4 </span><span class="p">❘</span><span class="w"></span>
<span class="w">		</span><span class="p">=</span><span class="w"> </span><span class="s">[din,dout,f,u] [x] (f (scalar x)) of (u (unitof x)) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">UnitTimes</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1, d2} unit d1 ⟶ unit d2 ⟶ unit (d1 *&#39; d2) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 *&#39;&#39; 4 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">UnitDiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1, d2} unit d1 ⟶ unit d2 ⟶ unit (d1 /&#39; d2) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 /&#39;&#39; 4 </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="kn">rule</span><span class="w"> </span><span class="s">rules?UnitEq </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">QEBase</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">/T A base Theory for dimensions ❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?Units </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?DimensionsExtended</span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Multiplying with numbers ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// QENMul : {x : dimension} real_lit ⟶ QE x ⟶ QE x ❘ # 2 . 3 ❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Dividing by numbers ❙</span><span class="w"></span>
<span class="w">  </span><span class="cm">// QENDiv : {x : dimension} QE x ⟶ real_lit ⟶ QE x ❘ # 2 /. 3 ❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Multiplying quantity expressions with each other. ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">QEMul</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x : dimension} {y: dimension} QE x ⟶ QE y ⟶ QE (x *&#39; y) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 ⋅ 4 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">/T Dividing quantity expressions with each other. ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">QEDiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x : dimension} {y: dimension} QE x ⟶ QE y ⟶ QE (x /&#39; y) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 / 4 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="cm">/T Adding quantity expressions (maintains dimension). ❙</span><span class="w"></span>
<span class="w">  </span><span class="no">QEAdd</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x : dimension} QE x ⟶ QE x ⟶ QE x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 ++ 3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QESubtract</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x: dimension} QE x ⟶ QE x ⟶ QE x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 - 3 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QEMinus</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{x: dimension} QE x ⟶ QE x </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ~ 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QEEExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone ⟶ QE DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> exp 1 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">QEExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone ⟶ QE DimNone ⟶ QE DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 ↑ 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">QEELog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone ⟶ QE DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ln 1 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">QELog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">QE DimNone ⟶ QE DimNone ⟶ QE DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> log 1 2 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">Field</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">fnd:?Logic</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="kn">include</span><span class="w"> </span><span class="s">?QEBase</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="cm">// For now, it&#39;ll be assumed space is of Length dimension by default, </span>
<span class="cm">  but that will have to be specified later for differntiating and integrating</span>
<span class="cm">  over fields defined on space of an arbitrary variable dimension❙</span><span class="w"></span>

<span class="w">  </span><span class="no">space</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">type </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">spaceDim</span><span class="p">:</span><span class="w"> </span><span class="s">dimension </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Length </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">field</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">dimension ⟶ type </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">[d]	space ⟶ QE d </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">FieldAdd</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d  ⟶ field d  ⟶ field d </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 .+ 3 </span><span class="p">❘</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f1,f2] [s] (f1 s) ++ (f2 s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldSubtract</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d ⟶ field d  ⟶ field d </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 .- 3 </span><span class="p">❘</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f1,f2] [s] (f1 s) - (f2 s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldMul</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1: dimension, d2: dimension} field d1 ⟶ field d2  ⟶ field (d1 *&#39; d2) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 .* 4 </span><span class="p">❘</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d1,d2,f1,f2] [s] (f1 s) ⋅ (f2 s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldDiv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d1: dimension, d2: dimension} field d1 ⟶ field d2  ⟶ field (d1 /&#39; d2) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 3 ./ 4 </span><span class="p">❘</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d1,d2,f1,f2] [s] (f1 s) / (f2 s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">FieldMinus</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d  ⟶ field d </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> .~ 2 </span><span class="p">❘</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f] [s] ~ (f s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	         </span>
<span class="w">	</span><span class="no">FieldEExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone ⟶ field DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> exp. 1 </span><span class="p">❘</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f] [s] exp (f s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">					 </span>
<span class="w">	</span><span class="no">FieldExp</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone ⟶ field DimNone ⟶ field DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 1 .↑ 2 </span><span class="p">❘</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f1,f2] [s] (f1 s) ↑ (f2 s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">					 </span>
<span class="w">	</span><span class="no">FieldLog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone ⟶ field DimNone ⟶ field DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> log. 1 2 </span><span class="p">❘</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f1,f2] [s] log (f1 s) (f2 s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">					 </span>
<span class="w">	</span><span class="no">FieldELog</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">field DimNone ⟶ field DimNone </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ln. 1 </span><span class="p">❘</span><span class="w"></span>
<span class="w">					 </span><span class="p">=</span><span class="w"> </span><span class="s">[f] [s] ln (f s) </span><span class="p">❙</span><span class="w"></span>

<span class="w">	</span><span class="no">FieldEq</span><span class="w">  </span><span class="p">:</span><span class="w"> </span><span class="s">{d: dimension} field d ⟶ field d  ⟶ prop </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> 2 .≐ 3 </span><span class="k">prec</span><span class="w"> </span><span class="mi">-5</span><span class="w"> </span><span class="p">❘</span><span class="w"></span>
<span class="w">	         </span><span class="p">=</span><span class="w"> </span><span class="s">[d,f1,f2] ∀ [s] (f1 s) ≐ (f2 s) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	         </span>
<span class="w">	</span><span class="no">FieldInteg</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d} field d ⟶ field (d *&#39; spaceDim) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> ∑. 2 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">FieldDeriv</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{d} field d ⟶ field (d /&#39; spaceDim) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> Δ. 2 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kn">namespace</span><span class="w"> </span><span class="s">http://mathhub.info/MitM/Foundation/Units</span><span class="w"> </span><span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">SIUnits</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?QEBase</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">  </span><span class="cm">// include ?InformationBase❙</span><span class="w"></span>
<span class="w">  </span>
<span class="w">  </span><span class="no">NormedUnit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">{a,b,c,d,e,f,g}unit (NormedDimension a b c d e f g) </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> NormedUnit 1 2 3 4 5 6 7 </span><span class="p">❙</span><span class="w"></span>

<span class="w">  </span><span class="no">Meter</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Length </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 1 0 0 0 0 0 0 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Second</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Time</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 0 1 0 0 0 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Kilogram</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Mass</span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> kg </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 1 0 0 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Mole</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Amount </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 1 0 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Kelvin</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Temperature</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 1 0 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Ampere</span><span class="p">:</span><span class="w"> </span><span class="s">unit Current</span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 0 1 0</span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Candela</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit LuminousIntensity </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 0 0 1 </span><span class="p">❙</span><span class="w"></span>
<span class="w">  </span><span class="no">Scalar</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit DimNone </span><span class="p">❘</span><span class="w"> </span><span class="cm">// = NormedUnit 0 0 0 0 0 0 0 </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>

<span class="kd">theory</span><span class="w"> </span><span class="nv">UnitsExtended</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="nv">?DimensionsExtended</span><span class="w"> </span><span class="p">=</span><span class="w"></span>
<span class="w">	</span><span class="kn">include</span><span class="w"> </span><span class="s">?SIUnits </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">bit</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Information </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Scalar </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">m2</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Area </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Meter *&#39;&#39; Meter </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> m² </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">m3</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Volume </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">m² *&#39;&#39; Meter </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> m³ </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">mps</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Velocity </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Meter /&#39;&#39; Second </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">mpss</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Acceleration </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">Meter /&#39;&#39; (Second *&#39;&#39; Second) </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">newton</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Force </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">kg *&#39;&#39; mpss </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> N </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span><span class="no">pascal</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Pressure </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">N /&#39;&#39; m² </span><span class="p">❘</span><span class="w"> </span><span class="p">#</span><span class="s"> Pa </span><span class="p">❙</span><span class="w"></span>
<span class="w">	</span>
<span class="w">	</span><span class="no">joule</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="s">unit Energy </span><span class="p">❘</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">N *&#39;&#39; Meter </span><span class="p">❙</span><span class="w"></span>
<span class="p">❚</span><span class="w"></span>
</pre></div>
</body></html>